{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AWS Lambda Powertools for .NET","text":""},{"location":"#aws-lambda-powertools-for-net","title":"AWS Lambda Powertools for .NET","text":"<p>AWS Lambda Powertools for .NET (which from here will be referred as Powertools) is a suite of utilities for AWS Lambda functions to ease adopting best practices such as tracing, structured logging, custom metrics, and more. Please note, Powertools is optimized for .NET 6+.</p> Tip <p>Powertools is also available for Python, Java, and TypeScript.</p> Support this project by becoming a reference customer or sharing your work  <p>You can choose to support us in three ways:</p> <p>1) Become a reference customers. This gives us permission to list your company in our documentation.</p> <p>2) Share your work. Blog posts, video, sample projects you used Powertools!</p>"},{"location":"#features","title":"Features","text":"<p>Core utilities such as Tracing, Logging, and Metrics will be available across all Lambda Powertools languages. Additional utilities are subjective to each language ecosystem and customer demand.</p> Utility Description Tracing Decorators and utilities to trace Lambda function handlers, and both synchronous and asynchronous functions Logger Structured logging made easier, and decorator to enrich structured logging with key Lambda context details Metrics Custom AWS metrics created asynchronously via CloudWatch Embedded Metric Format (EMF)"},{"location":"#install","title":"Install","text":"<p>Powertools are available as NuGet packages. You can install the packages from NuGet gallery or from Visual Studio editor. Search <code>AWS.Lambda.Powertools*</code> to see various utilities available.</p> <ul> <li> <p>AWS.Lambda.Powertools.Tracing:</p> <p><code>dotnet nuget add AWS.Lambda.Powertools.Tracing</code></p> </li> <li> <p>AWS.Lambda.Powertools.Logging:</p> <p><code>dotnet nuget add AWS.Lambda.Powertools.Logging</code></p> </li> <li> <p>AWS.Lambda.Powertools.Metrics:</p> <p><code>dotnet nuget add AWS.Lambda.Powertools.Metrics</code></p> </li> </ul>"},{"location":"#sam-cli-custom-template","title":"SAM CLI custom template","text":"<p>We have provided you with a custom template for the Serverless Application Model (AWS SAM) command-line interface (CLI). This generates a starter project that allows you to interactively choose the Powertools features that enables you to include in your project.</p> <pre><code>sam init --location https://github.com/aws-samples/cookiecutter-aws-sam-dotnet\n</code></pre> <p>To use the SAM CLI, you need the following tools.</p> <ul> <li>SAM CLI - Install the SAM CLI</li> <li>.NET 6.0 (LTS)  - Install .NET 6.0</li> <li>Docker - Install Docker community edition</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>We have provided a few examples that should you how to use the each of the core Powertools features.</p> <ul> <li>Tracing example</li> <li>Logging example</li> <li>Metrics example</li> </ul>"},{"location":"#connect","title":"Connect","text":"<ul> <li>AWS Lambda Powertools on Discord: <code>#dotnet</code> - Invite link</li> <li>Email: aws-lambda-powertools-feedback@amazon.com</li> </ul>"},{"location":"#tenets","title":"Tenets","text":"<p>These are our core principles to guide our decision making.</p> <ul> <li>AWS Lambda only. We optimize for AWS Lambda function environments and supported runtimes only. Utilities might work with web frameworks and non-Lambda environments, though they are not officially supported.</li> <li>Eases the adoption of best practices. The main priority of the utilities is to facilitate best practices adoption, as defined in the AWS Well-Architected Serverless Lens; all other functionality is optional.</li> <li>Keep it lean. Additional dependencies are carefully considered for security and ease of maintenance, and prevent negatively impacting startup time.</li> <li>We strive for backwards compatibility. New features and changes should keep backwards compatibility. If a breaking change cannot be avoided, the deprecation and migration process should be clearly defined.</li> <li>We work backwards from the community. We aim to strike a balance of what would work best for 80% of customers. Emerging practices are considered and discussed via Requests for Comment (RFCs)</li> <li>Idiomatic. Utilities follow programming language idioms and language-specific best practices.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. See Conventional Commits for commit guidelines.</p> <p></p>"},{"location":"changelog/#v101-2023-04-06","title":"v1.0.1 - 2023-04-06","text":""},{"location":"changelog/#pull-requests","title":"Pull Requests","text":"<ul> <li>Merge pull request #232 from amirkaws/amirkaws-release-v1.0.1</li> <li>Merge pull request #227 from hjgraca/chore_fix_changelog_build</li> <li>Merge pull request #225 from srcsakthivel/develop</li> <li>Merge pull request #223 from hjgraca/fix_tracing_on_exception_thrown</li> <li>Merge pull request #218 from amirkaws/amirkaws-update-examples-nuget-references-release</li> </ul>"},{"location":"changelog/#v100-2023-02-24","title":"v1.0.0 - 2023-02-24","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>removing manual trigger on docs wf</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>home: update powertools definition</li> </ul>"},{"location":"changelog/#maintenance","title":"Maintenance","text":"<ul> <li>ci: api docs build update (#188)</li> <li>ci: changing trigger to run manually</li> <li>ci: updated api docs implementation</li> <li>ci: updated bug report template</li> <li>deps: updates sample deps</li> <li>docs: incorrect crefs</li> </ul>"},{"location":"changelog/#pull-requests_1","title":"Pull Requests","text":"<ul> <li>Merge pull request #215 from amirkaws/amirkaws-release-v1.0.0</li> <li>Merge pull request #208 from amirkaws/amirkaws-cold-start-capture-warning-bug-fix</li> <li>Merge pull request #210 from awslabs/powertools-definition-update</li> <li>Merge pull request #209 from amirkaws/amirkaws-metrics-timestamp-fix</li> <li>Merge pull request #199 from awslabs/sliedig-ci-reviewers</li> <li>Merge pull request #193 from hjgraca/maintenance-new-issue-template</li> <li>Merge pull request #202 from hjgraca/fix-test-json-escaping</li> <li>Merge pull request #195 from hjgraca/update-dotnet-sdk-6.0.405</li> <li>Merge pull request #194 from hjgraca/patch-1</li> <li>Merge pull request #192 from hjgraca/fix-incorrect-crefs</li> <li>Merge pull request #189 from sliedig/develop</li> <li>Merge pull request #185 from amirkaws/amirkaws-update-examples-nuget-references</li> <li>Merge pull request #183 from awslabs/develop</li> <li>Merge pull request #150 from awslabs/develop</li> <li>Merge pull request #140 from awslabs/develop</li> </ul>"},{"location":"changelog/#v002-preview-2023-01-18","title":"v0.0.2-preview - 2023-01-18","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>removed duplicate template issue</li> <li>updated logger casing env vars in samples</li> </ul>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>typo in metrics README</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>ci: codeql static code analysis (#148)</li> </ul>"},{"location":"changelog/#maintenance_1","title":"Maintenance","text":"<ul> <li>updated setup-dotnet@v1 to @v3</li> <li>updated packages (#172)</li> <li>ci: bumped version</li> <li>ci: minor updates, licensing</li> <li>deps: bump gitpython from 3.1.29 to 3.1.30</li> <li>docs: updated documentation (#175)</li> <li>docs: add discord invitation link</li> </ul>"},{"location":"changelog/#pull-requests_2","title":"Pull Requests","text":"<ul> <li>Merge pull request #182 from sliedig/develop</li> <li>Merge pull request #181 from awslabs/dependabot/pip/gitpython-3.1.30</li> <li>Merge pull request #179 from sliedig/sliedig-ci</li> <li>Merge pull request #174 from sliedig/sliedig-ci</li> <li>Merge pull request #173 from sliedig/sliedig-samples</li> <li>Merge pull request #157 from kenfdev/fix-readme-title-typo</li> <li>Merge pull request #170 from nCubed/develop</li> <li>Merge pull request #152 from amirkaws/amirkaws-custom-exception-json-converter</li> <li>Merge pull request #155 from sthuber90/add-discord-link-154</li> <li>Merge pull request #147 from amirkaws/amirkaws-fix-doc-links</li> </ul>"},{"location":"changelog/#v001-preview1-2022-08-01","title":"v0.0.1-preview.1 - 2022-08-01","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>force directy rename</li> <li>making test function compile.</li> <li>updating issue templates with correct extention</li> <li>updated auto assign</li> <li>skip duplicate nuget packages publish</li> <li>added missing runtimes</li> <li>updated Logging template description</li> <li>updated documentation and doc generation (#96)</li> <li>removed optional doc file paths</li> <li>explicitly adding doc files for build configurations</li> <li>resolving dependecy alert CVE-2020-8116</li> <li>added missing codecov packages for test projects</li> <li>fixed build</li> <li>forcing rename</li> <li>fixed powertolls spelling in docs</li> <li>replaced PackageIconUrl which is being depreciated with PackageIcon</li> <li>added missing include to pack README files</li> <li>fixing node vulnerabilites for docs</li> <li>resolving merge conflict</li> <li>update packages to resolve vulnerabilities. Switched to yarn package manager</li> <li>intermin fix to resolve vulnerability issues.</li> <li>proj references</li> <li>fixed spelling in libraries folder name</li> <li>ci: lockdown gh-pages workflow to sha</li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>fixed nav for roadmap</li> <li>updated link to feature request; added roadmap</li> <li>library readme updates and minor updates  (#117)</li> <li>spell check with US-English dictionary (#115)</li> <li>docs review (#112)</li> <li>Reviewing documentation (#68)</li> <li>adding auto-generated API Reference to docs (#87)</li> <li>alternative brew installation (#86)</li> <li>homebrew installation (#85)</li> <li>merging api generation tasks (#84)</li> <li>fixing docfx path (#83)</li> <li>fix docfx path (#82)</li> <li>fix api docs generator installation (#81)</li> <li>update github actions to publish api docs (#80)</li> <li>API docs generation (#79)</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>added security.md</li> <li>updated record_pr action</li> <li>PR Labeler GitHub actions (#119)</li> <li>Logger output case attributes docs and unit testing (#100)</li> <li>add extra fields to the logger methods (#98)</li> <li>updated examples to include managed runtime configuration as well as docker. Made updates to Tracing implementation</li> <li>added Tracing example</li> <li>added init Metrics sample</li> <li>added Logging example</li> <li>added serialisation options to force dictionary keys to camel case</li> <li>added build tools to generate nuget packages</li> <li>updated project packaging properties</li> <li>added package README files for core utilities</li> <li>update make and doc dep to build docs</li> <li>added docs template</li> </ul>"},{"location":"changelog/#maintenance_2","title":"Maintenance","text":"<ul> <li>set global .net version</li> <li>temporarily removing docs while content is being developed</li> <li>added example project</li> <li>refctored PowerTools to Powertools</li> <li>added github files and templates</li> <li>initial folder structure</li> <li>interim resolution of docs package vulnerabilities</li> <li>migrated AWS.Lambda.PowerTools to AWS.Lambda.PowerTools.Common namespace. fix: resolved incorrect namespace for Tracing fix: resolved dependencies in example project</li> <li>refactored to new namespace</li> <li>updated readme</li> <li>updated github templates</li> <li>added customer 404 page</li> <li>removing unecessary buildtools</li> <li>update pr template</li> <li>updating type documentation and file headers (#56)</li> <li>moved solution file into libraries. Need a separate solution for examples</li> <li>added docs</li> <li>added gitignore and updated licence</li> <li>updating doc build workflow</li> <li>updated issue templates</li> <li>updated Label PR based on title action</li> <li>deleted unnecessay publishing action</li> <li>updated stale action</li> <li>removed unnecessary pr labeling</li> <li>updated PR labeling path</li> <li>updated list of assignees</li> <li>updated docker builds to use Amazon.Lambda.Tools (#118)</li> <li>bumped .net version in global to 6.0.301 (#120)</li> <li>bumped .net version in global to 6.0.301</li> <li>adding missed copyright info</li> <li>added copyright to examples</li> <li>removed SimpleLambda from examples</li> <li>cleaned up logging and metrics functions</li> <li>ci: add on_merge_pr workflow to notify releases</li> <li>ci: lockdown untrusted workflows to sha</li> <li>ci: add missing scripts</li> <li>ci: updated bug report template (#144)</li> <li>ci: add workflow to detect missing related issue</li> <li>ci: enable concurrency group for docs workflow</li> <li>ci: upudated wording in PR template checklist</li> <li>ci: added codeowners</li> <li>ci: added Maintainers doc</li> <li>ci: updated PR workflows and scripts</li> <li>ci: upgrade setup-python to v4</li> <li>ci: upgrade checkout action to v3</li> <li>ci: use untrusted workflows with sha</li> <li>ci: add reusable export pr workflow dependency</li> <li>deps: bump hosted-git-info from 2.8.8 to 2.8.9 in /docs</li> <li>deps: bump object-path from 0.11.4 to 0.11.5 in /docs</li> <li>deps: bump ssri from 6.0.1 to 6.0.2 in /docs</li> <li>deps: bump elliptic from 6.5.3 to 6.5.4 in /docs</li> <li>deps: bump socket.io from 2.3.0 to 2.4.1 in /docs</li> <li>deps: bump ini from 1.3.5 to 1.3.8 in /docs</li> <li>deps: bump ua-parser-js from 0.7.23 to 0.7.28 in /docs</li> <li>deps: bump underscore from 1.12.0 to 1.13.1 in /docs</li> <li>deps: bump url-parse from 1.4.7 to 1.5.1 in /docs</li> <li>deps: bump prismjs from 1.20.0 to 1.21.0 in /docs</li> <li>deps: updates sample deps (#142)</li> <li>deps: bump mkdocs from 1.2.2 to 1.2.3 (#29)</li> <li>governance: render debug logs with csharp syntax</li> <li>governance: typo in pending release label name</li> </ul>"},{"location":"changelog/#pull-requests_3","title":"Pull Requests","text":"<ul> <li>Merge pull request #139 from awslabs/amirkaws-resolve-conflicts-2</li> <li>Merge pull request #135 from awslabs/amirkaws-update-versions</li> <li>Merge pull request #134 from heitorlessa/chore/lockdown-gh-pages-workflow</li> <li>Merge pull request #132 from heitorlessa/chore/github-concurrency-docs</li> <li>Merge pull request #130 from heitorlessa/chore/enforce-github-actions-sha</li> <li>Merge pull request #128 from sliedig/sliedig-ci</li> <li>Merge pull request #127 from sliedig/sliedig-ci</li> <li>Merge pull request #126 from sliedig/develop</li> <li>Merge pull request #123 from sliedig/develop</li> <li>Merge pull request #1 from sliedig/sliedig/develop</li> <li>Merge pull request #121 from awslabs/amirkaws-update-versions</li> <li>Merge pull request #116 from awslabs/amirkaws/add-di-support-for-logging</li> <li>Merge pull request #113 from awslabs/amirkaws/update-doc-1</li> <li>Merge pull request #111 from awslabs/amirkaws/add-env-vars-docs</li> <li>Merge pull request #102 from sliedig/sliedig/examples</li> <li>Merge pull request #103 from awslabs/amirkaws/fix-example-issues</li> <li>Merge pull request #97 from sliedig/sliedig/examples</li> <li>Merge pull request #95 from awslabs/pr/91</li> <li>Merge pull request #90 from sliedig/develop</li> <li>Merge pull request #89 from awslabs/api-docs-template</li> <li>Merge pull request #74 from awslabs/amirkaws/disable-tracing-outside-lambda-env</li> <li>Merge pull request #66 from sliedig/develop</li> <li>Merge pull request #59 from sliedig/develop</li> <li>Merge pull request #58 from sliedig/sliedig/nuget</li> <li>Merge pull request #32 from awslabs/amirkaws/metrics-1</li> <li>Merge pull request #31 from t1agob/develop</li> <li>Merge pull request #2 from awslabs/develop</li> <li>Merge pull request #25 from t1agob/develop</li> <li>Merge pull request #1 from t1agob/sourcegenerators</li> <li>Merge pull request #24 from sliedig/develop</li> <li>Merge pull request #23 from sliedig/develop</li> <li>Merge pull request #22 from sliedig/develop</li> <li>Merge pull request #21 from t1agob/develop</li> <li>Merge pull request #19 from awslabs/dependabot/npm_and_yarn/docs/url-parse-1.5.1</li> <li>Merge pull request #18 from awslabs/dependabot/npm_and_yarn/docs/hosted-git-info-2.8.9</li> <li>Merge pull request #17 from awslabs/dependabot/npm_and_yarn/docs/ua-parser-js-0.7.28</li> <li>Merge pull request #16 from awslabs/dependabot/npm_and_yarn/docs/underscore-1.13.1</li> <li>Merge pull request #15 from awslabs/dependabot/npm_and_yarn/docs/ssri-6.0.2</li> <li>Merge pull request #14 from awslabs/dependabot/npm_and_yarn/docs/elliptic-6.5.4</li> <li>Merge pull request #13 from sliedig/develop</li> <li>Merge pull request #12 from sliedig/develop</li> <li>Merge pull request #11 from awslabs/dependabot/npm_and_yarn/docs/socket.io-2.4.1</li> <li>Merge pull request #10 from awslabs/dependabot/npm_and_yarn/docs/ini-1.3.8</li> <li>Merge pull request #9 from awslabs/dependabot/npm_and_yarn/docs/object-path-0.11.5</li> <li>Merge pull request #7 from t1agob/develop</li> <li>Merge pull request #8 from sliedig/develop</li> <li>Merge pull request #5 from sliedig/develop</li> <li>Merge pull request #4 from sliedig/develop</li> <li>Merge pull request #3 from sliedig/develop</li> <li>Merge pull request #2 from awslabs/dependabot/npm_and_yarn/docs/prismjs-1.21.0</li> <li>Merge pull request #1 from sliedig/develop</li> </ul>"},{"location":"references/","title":"AWS Lambda Powertools for .NET references","text":""},{"location":"references/#environment-variables","title":"Environment variables","text":"<p>Info</p> <p>Explicit parameters take precedence over environment variables.</p> Environment variable Description Utility Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging All <code>\"service_undefined\"</code> POWERTOOLS_LOG_LEVEL Sets logging level Logging <code>Information</code> POWERTOOLS_LOGGER_CASE Override the default casing for log keys Logging <code>SnakeCase</code> POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event Logging <code>false</code> POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling Logging <code>0</code> POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics Metrics <code>None</code> POWERTOOLS_TRACE_DISABLED Disables tracing Tracing <code>false</code> POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. Tracing <code>true</code> POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. Tracing <code>true</code>"},{"location":"references/#sam-template-snippets","title":"SAM template snippets","text":""},{"location":"references/#logging","title":"Logging","text":"<pre><code># Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: MIT-0\nAWSTemplateFormatVersion: \"2010-09-09\"\nTransform: AWS::Serverless-2016-10-31\nDescription: &gt;\nExample project for Powertools Logging utility\n\n# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst\nGlobals:\nFunction:\nTimeout: 10\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: powertools-dotnet-logging-sample\nPOWERTOOLS_LOG_LEVEL: Debug\nPOWERTOOLS_LOGGER_LOG_EVENT: true\nPOWERTOOLS_LOGGER_CASE: PascalCase # Allowed values are: CamelCase, PascalCase and SnakeCase\nPOWERTOOLS_LOGGER_SAMPLE_RATE: 0\n</code></pre>"},{"location":"references/#metrics","title":"Metrics","text":"<pre><code># Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: MIT-0\nAWSTemplateFormatVersion: \"2010-09-09\"\nTransform: AWS::Serverless-2016-10-31\nDescription: &gt;\nExample project for Powertools Metrics utility\n\n# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst\nGlobals:\nFunction:\nTimeout: 10\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: powertools-dotnet-metrics-sample # This can also be set using the Metrics decorator on your handler [Metrics(Namespace = \"aws-lambda-powertools\"]\nPOWERTOOLS_METRICS_NAMESPACE: AWSLambdaPowertools # This can also be set using the Metrics decorator on your handler [Metrics(Namespace = \"aws-lambda-powertools\"]\n</code></pre>"},{"location":"references/#tracing","title":"Tracing","text":"<pre><code># Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: MIT-0\nAWSTemplateFormatVersion: \"2010-09-09\"\nTransform: AWS::Serverless-2016-10-31\nDescription: &gt;\nExample project for Powertools tracing utility\n\n# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst\nGlobals:\nFunction:\nTimeout: 10\nTracing: Active\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: powertools-dotnet-tracing-sample\nPOWERTOOLS_TRACE_DISABLED: true\nPOWERTOOLS_TRACER_CAPTURE_RESPONSE: true\nPOWERTOOLS_TRACER_CAPTURE_ERROR: true     # To disable tracing (CaptureMode = TracingCaptureMode.Disabled)\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#overview","title":"Overview","text":"<p>This is our public roadmap that outlines the high level direction we are working towards, namely Themes. We update this document when our priorities change: security and stability is our top priority.</p> <p>See our latest list of activities \u00bb</p>"},{"location":"roadmap/#themes","title":"Themes","text":"<p>Themes are key activities maintainers are focusing on, besides bug reports. These are updated periodically and you can find the latest under Epics in our public board.</p>"},{"location":"roadmap/#revamp-roadmap","title":"Revamp roadmap","text":"<p>We are beta testing the new GitHub Projects Beta to provide more visibility on our current activities. This also includes new GitHub Issue Forms Beta to streamline feature requests, bug reports, RFCs, etc., including a new mechanism to add external links like <code>Ask a Question</code>.</p> <p>Once complete, we will repurpose our central roadmap repository to provide a landing page for all Powertools languages, including an experiment to better highlight feature parity across them.</p>"},{"location":"roadmap/#disclaimer","title":"Disclaimer","text":"<p>The AWS Lambda Powertools team values feedback and guidance from its community of users, although final decisions on inclusion into the project will be made by AWS.</p> <p>We determine the high-level direction for our open roadmap based on customer feedback and popularity (\ud83d\udc4d\ud83c\udffd and comments), security and operational impacts, and business value. Where features don\u2019t meet our goals and longer-term strategy, we will communicate that clearly and openly as quickly as possible with an explanation of why the decision was made.</p>"},{"location":"roadmap/#faqs","title":"FAQs","text":"<p>Q: Why did you build this?</p> <p>A: We know that our customers are making decisions and plans based on what we are developing, and we want to provide our customers the insights they need to plan.</p> <p>Q: Why are there no dates on your roadmap?</p> <p>A: Because job zero is security and operational stability, we can't provide specific target dates for features. The roadmap is subject to change at any time, and roadmap issues in this repository do not guarantee a feature will be launched as proposed.</p> <p>Q: How can I provide feedback or ask for more information?</p> <p>A: For existing features, you can directly comment on issues. For anything else, please open an issue.</p>"},{"location":"tenets/","title":"AWS Lambda Powertools for .NET (developer preview)","text":"<p>Core utilities such as Tracing, Logging, Metrics, and Event Handler will be available across all Powertools runtimes. Additional utilities are subjective to each language ecosystem and customer demand.</p> <ul> <li>AWS Lambda only. We optimize for AWS Lambda function environments and supported runtimes only. Utilities might work with web frameworks and non-Lambda environments, though they are not officially supported.</li> <li>Eases the adoption of best practices. The main priority of the utilities is to facilitate best practices adoption, as defined in the AWS Well-Architected Serverless Lens; all other functionality is optional.</li> <li>Keep it lean. Additional dependencies are carefully considered for security and ease of maintenance, and prevent negatively impacting startup time.</li> <li>We strive for backwards compatibility. New features and changes should keep backwards compatibility. If a breaking change cannot be avoided, the deprecation and migration process should be clearly defined.</li> <li>We work backwards from the community. We aim to strike a balance of what would work best for 80% of customers. Emerging practices are considered and discussed via Requests for Comment (RFCs)</li> <li>Idiomatic. Utilities follow programming language idioms and language-specific best practices.</li> </ul>"},{"location":"we_made_this/","title":"We Made This (Community)","text":"<p>This space is dedicated to highlight our awesome community content featuring Powertools \ud83d\ude4f!</p> <p>Get your content featured here!</p>"},{"location":"we_made_this/#connect","title":"Connect","text":"<p>Join us on Discord to connect with the Powertools community \ud83d\udc4b. Ask questions, learn from each other, contribute, hang out with key contributors, and more!</p>"},{"location":"core/logging/","title":"Logging","text":"<p>The logging utility provides a Lambda optimized logger with output structured as JSON.</p>"},{"location":"core/logging/#key-features","title":"Key features","text":"<ul> <li>Capture key fields from Lambda context, cold start and structures logging output as JSON</li> <li>Log Lambda event when instructed (disabled by default)</li> <li>Log sampling enables DEBUG log level for a percentage of requests (disabled by default)</li> <li>Append additional keys to structured log at any point in time</li> </ul>"},{"location":"core/logging/#getting-started","title":"Getting started","text":"<p>Logging requires two settings:</p> Setting Description Environment variable Attribute parameter Service Sets Service key that will be present across all log statements <code>POWERTOOLS_SERVICE_NAME</code> <code>Service</code> Logging level Sets how verbose Logger should be (Information, by default) <code>POWERTOOLS_LOG_LEVEL</code> <code>LogLevel</code>"},{"location":"core/logging/#example-using-aws-serverless-application-model-aws-sam","title":"Example using AWS Serverless Application Model (AWS SAM)","text":"<p>You can override log level by setting <code>POWERTOOLS_LOG_LEVEL</code> environment variable in the AWS SAM template.</p> <p>You can also explicitly set a service name via <code>POWERTOOLS_SERVICE_NAME</code> environment variable. This sets Service key that will be present across all log statements.</p> <p>Here is an example using the AWS SAM Globals section.</p> template.yaml <pre><code># Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: MIT-0\nAWSTemplateFormatVersion: \"2010-09-09\"\nTransform: AWS::Serverless-2016-10-31\nDescription: &gt;\nExample project for Powertools Logging utility\n\nGlobals:\nFunction:\nTimeout: 10\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: powertools-dotnet-logging-sample\nPOWERTOOLS_LOG_LEVEL: Debug\nPOWERTOOLS_LOGGER_LOG_EVENT: true\nPOWERTOOLS_LOGGER_CASE: PascalCase # Allowed values are: CamelCase, PascalCase and SnakeCase\nPOWERTOOLS_LOGGER_SAMPLE_RATE: 0\n</code></pre>"},{"location":"core/logging/#full-list-of-environment-variables","title":"Full list of environment variables","text":"Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging <code>\"service_undefined\"</code> POWERTOOLS_LOG_LEVEL Sets logging level <code>Information</code> POWERTOOLS_LOGGER_CASE Override the default casing for log keys <code>SnakeCase</code> POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event <code>false</code> POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling <code>0</code>"},{"location":"core/logging/#standard-structured-keys","title":"Standard structured keys","text":"<p>Your logs will always include the following keys to your structured logging:</p> Key Type Example Description Timestamp string \"2020-05-24 18:17:33,774\" Timestamp of actual log statement Level string \"Information\" Logging level Name string \"Powertools Logger\" Logger name ColdStart bool true ColdStart value. Service string \"payment\" Service name defined. \"service_undefined\" will be used if unknown SamplingRate int 0.1 Debug logging sampling rate in percentage e.g. 10% in this case Message string \"Collecting payment\" Log statement value. Unserializable JSON values will be cast to string FunctionName string \"example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" FunctionVersion string \"12\" FunctionMemorySize string \"128\" FunctionArn string \"arn:aws:lambda:eu-west-1:012345678910:function:example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" XRayTraceId string \"1-5759e988-bd862e3fe1be46a994272793\" X-Ray Trace ID when Lambda function has enabled Tracing FunctionRequestId string \"899856cb-83d1-40d7-8611-9e78f15f32f4\" AWS Request ID from lambda context"},{"location":"core/logging/#logging-incoming-event","title":"Logging incoming event","text":"<p>When debugging in non-production environments, you can instruct Logger to log the incoming event with <code>LogEvent</code> parameter or via <code>POWERTOOLS_LOGGER_LOG_EVENT</code> environment variable.</p> <p>Warning</p> <p>Log event is disabled by default to prevent sensitive info being logged.</p> Function.cs <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(LogEvent = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre>"},{"location":"core/logging/#setting-a-correlation-id","title":"Setting a Correlation ID","text":"<p>You can set a Correlation ID using <code>CorrelationIdPath</code> parameter by passing a JSON Pointer expression.</p> Function.csExample EventExample CloudWatch Logs excerpt <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(CorrelationIdPath = \"/headers/my_request_id_header\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <pre><code>{\n\"headers\": {\n\"my_request_id_header\": \"correlation_id_value\"\n}\n}\n</code></pre> <pre><code>{\n\"cold_start\": true,\n\"xray_trace_id\": \"1-61b7add4-66532bb81441e1b060389429\",\n\"function_name\": \"test\",\n\"function_version\": \"$LATEST\",\n\"function_memory_size\": 128,\n\"function_arn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"function_request_id\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"level\": \"Information\",\n\"service\": \"lambda-example\",\n\"name\": \"AWS.Lambda.Powertools.Logging.Logger\",\n\"message\": \"Collecting payment\",\n\"sampling_rate\": 0.7,\n\"correlation_id\": \"correlation_id_value\",\n}\n</code></pre> <p>We provide built-in JSON Pointer expression for known event sources, where either a request ID or X-Ray Trace ID are present.</p> Function.csExample EventExample CloudWatch Logs excerpt <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(CorrelationIdPath = CorrelationIdPaths.API_GATEWAY_REST)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <pre><code>{\n\"RequestContext\": {\n\"RequestId\": \"correlation_id_value\"\n}\n}\n</code></pre> <pre><code>{\n\"cold_start\": true,\n\"xray_trace_id\": \"1-61b7add4-66532bb81441e1b060389429\",\n\"function_name\": \"test\",\n\"function_version\": \"$LATEST\",\n\"function_memory_size\": 128,\n\"function_arn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"function_request_id\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"level\": \"Information\",\n\"service\": \"lambda-example\",\n\"name\": \"AWS.Lambda.Powertools.Logging.Logger\",\n\"message\": \"Collecting payment\",\n\"sampling_rate\": 0.7,\n\"correlation_id\": \"correlation_id_value\",\n}\n</code></pre>"},{"location":"core/logging/#appending-additional-keys","title":"Appending additional keys","text":"<p>Custom keys are persisted across warm invocations<p>Always set additional keys as part of your handler to ensure they have the latest value, or explicitly clear them with <code>ClearState=true</code>.</p> </p> <p>You can append your own keys to your existing logs via <code>AppendKey</code>. Typically this value would be passed into the function via the event. Appended keys are added to all subsequent log entries in the current execution from the point the logger method is called. To ensure the key is added to all log entries, call this method as early as possible in the Lambda handler.</p> Function.csExample CloudWatch Logs excerpt <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(LogEvent = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigwProxyEvent,\nILambdaContext context)\n{\nvar requestContextRequestId = apigwProxyEvent.RequestContext.RequestId;\n\nvar lookupInfo = new Dictionary&lt;string, object&gt;()\n{\n{\"LookupInfo\", new Dictionary&lt;string, object&gt;{{ \"LookupId\", requestContextRequestId }}}\n};  // Appended keys are added to all subsequent log entries in the current execution.\n// Call this method as early as possible in the Lambda handler.\n// Typically this is value would be passed into the function via the event.\n// Set the ClearState = true to force the removal of keys across invocations,\nLogger.AppendKeys(lookupInfo);\nLogger.LogInformation(\"Getting ip address from external service\");\n\n}\n</code></pre> <pre><code>{\n\"cold_start\": false,\n\"xray_trace_id\": \"1-622eede0-647960c56a91f3b071a9fff1\",\n\"lookup_info\": {\n\"lookup_id\": \"4c50eace-8b1e-43d3-92ba-0efacf5d1625\"\n},\n\"function_name\": \"PowertoolsLoggingSample-HelloWorldFunction-hm1r10VT3lCy\",\n\"function_version\": \"$LATEST\",\n\"function_memory_size\": 256,\n\"function_arn\": \"arn:aws:lambda:ap-southeast-2:538510314095:function:PowertoolsLoggingSample-HelloWorldFunction-hm1r10VT3lCy\",\n\"function_request_id\": \"96570b2c-f00e-471c-94ad-b25e95ba7347\",\n\"timestamp\": \"2022-03-14T07:25:20.9418065Z\",\n\"level\": \"Information\",\n\"service\": \"powertools-dotnet-logging-sample\",\n\"name\": \"AWS.Lambda.Powertools.Logging.Logger\",\n\"message\": \"Getting ip address from external service\"\n}\n</code></pre>"},{"location":"core/logging/#removing-additional-keys","title":"Removing additional keys","text":"<p>You can remove any additional key from entry using <code>Logger.RemoveKeys()</code>.</p> Function.cs <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(LogEvent = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\nLogger.AppendKey(\"test\", \"willBeLogged\");\n...\nvar customKeys = new Dictionary&lt;string, string&gt;\n{\n{\"test1\", \"value1\"}, {\"test2\", \"value2\"}\n};\n\nLogger.AppendKeys(customKeys);\n...\nLogger.RemoveKeys(\"test\");\nLogger.RemoveKeys(\"test1\", \"test2\");\n...\n}\n}\n</code></pre>"},{"location":"core/logging/#extra-keys","title":"Extra Keys","text":"<p>Extra keys allow you to append additional keys to a log entry. Unlike <code>AppendKey</code>, extra keys will only apply to the current log entry.</p> <p>Extra keys argument is available for all log levels' methods, as implemented in the standard logging library - e.g. Logger.Information, Logger.Warning.</p> <p>It accepts any dictionary, and all keyword arguments will be added as part of the root structure of the logs for that log statement.</p> <p>Info<p>Any keyword argument added using extra keys will not be persisted for subsequent messages.</p> </p> Function.cs <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(LogEvent = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigwProxyEvent,\nILambdaContext context)\n{\nvar requestContextRequestId = apigwProxyEvent.RequestContext.RequestId;\n\nvar lookupId = new Dictionary&lt;string, object&gt;()\n{\n{ \"LookupId\", requestContextRequestId }\n};\n// Appended keys are added to all subsequent log entries in the current execution.\n// Call this method as early as possible in the Lambda handler.\n// Typically this is value would be passed into the function via the event.\n// Set the ClearState = true to force the removal of keys across invocations,\nLogger.AppendKeys(lookupId);\n}\n</code></pre>"},{"location":"core/logging/#clearing-all-state","title":"Clearing all state","text":"<p>Logger is commonly initialized in the global scope. Due to Lambda Execution Context reuse, this means that custom keys can be persisted across invocations. If you want all custom keys to be deleted, you can use <code>ClearState=true</code> attribute on <code>[Logging]</code> attribute.</p> Function.cs#1 Request#2 Request <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(ClearState = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\nif (apigProxyEvent.Headers.ContainsKey(\"SomeSpecialHeader\"))\n{\nLogger.AppendKey(\"SpecialKey\", \"value\");\n}\n\nLogger.LogInformation(\"Collecting payment\");\n...\n}\n}\n</code></pre> <pre><code>{\n\"level\": \"Information\",\n\"message\": \"Collecting payment\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"service\": \"payment\",\n\"cold_start\": true,\n\"function_name\": \"test\",\n\"function_memory_size\": 128,\n\"function_arn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"function_request_id\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\",\n\"special_key\": \"value\"\n}\n</code></pre> <pre><code>{\n\"level\": \"Information\",\n\"message\": \"Collecting payment\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"service\": \"payment\",\n\"cold_start\": true,\n\"function_name\": \"test\",\n\"function_memory_size\": 128,\n\"function_arn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"function_request_id\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\"\n}\n</code></pre>"},{"location":"core/logging/#sampling-debug-logs","title":"Sampling debug logs","text":"<p>You can dynamically set a percentage of your logs to DEBUG level via env var <code>POWERTOOLS_LOGGER_SAMPLE_RATE</code> or via <code>SamplingRate</code> parameter on attribute.</p> <p>Info</p> <p>Configuration on environment variable is given precedence over sampling rate configuration on attribute, provided it's in valid value range.</p> Sampling via attribute parameterSampling via environment variable <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(SamplingRate = 0.5)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nEnvironment:\nVariables:\nPOWERTOOLS_LOGGER_SAMPLE_RATE: 0.5\n</code></pre>"},{"location":"core/logging/#configure-log-output-casing","title":"Configure Log Output Casing","text":"<p>By definition Powertools outputs logging keys using snake case (e.g. \"function_memory_size\": 128). This allows developers using different Powertools runtimes, to search logs across services written in languages such as Python or TypeScript.</p> <p>If you want to override the default behavior you can either set the desired casing through attributes, as described in the example below, or by setting the <code>POWERTOOLS_LOGGER_CASE</code> environment variable on your AWS Lambda function. Allowed values are: <code>CamelCase</code>, <code>PascalCase</code> and <code>SnakeCase</code>.</p> Output casing via attribute parameter <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(LoggerOutputCase = LoggerOutputCase.CamelCase)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <p>Below are some output examples for different casing.</p> Camel CasePascal CaseSnake Case <pre><code>{\n\"level\": \"Information\",\n\"message\": \"Collecting payment\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"service\": \"payment\",\n\"coldStart\": true,\n\"functionName\": \"test\",\n\"functionMemorySize\": 128,\n\"functionArn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"functionRequestId\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\"\n}\n</code></pre> <pre><code>{\n\"Level\": \"Information\",\n\"Message\": \"Collecting payment\",\n\"Timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"Service\": \"payment\",\n\"ColdStart\": true,\n\"FunctionName\": \"test\",\n\"FunctionMemorySize\": 128,\n\"FunctionArn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"FunctionRequestId\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\"\n}\n</code></pre> <pre><code>{\n\"level\": \"Information\",\n\"message\": \"Collecting payment\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"service\": \"payment\",\n\"cold_start\": true,\n\"function_name\": \"test\",\n\"function_memory_size\": 128,\n\"function_arn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"function_request_id\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\"\n}\n</code></pre>"},{"location":"core/metrics/","title":"Metrics","text":"<p>Metrics creates custom metrics asynchronously by logging metrics to standard output following Amazon CloudWatch Embedded Metric Format (EMF).</p> <p>These metrics can be visualized through Amazon CloudWatch Console.</p>"},{"location":"core/metrics/#key-features","title":"Key features","text":"<ul> <li>Aggregate up to 100 metrics using a single CloudWatch EMF object (large JSON blob)</li> <li>Validating your metrics against common metric definitions mistakes (for example, metric unit, values, max dimensions, max metrics)</li> <li>Metrics are created asynchronously by the CloudWatch service. You do not need any custom stacks, and there is no impact to Lambda function latency</li> <li>Context manager to create a one off metric with a different dimension</li> </ul> Metrics showcase - Metrics Explorer"},{"location":"core/metrics/#terminologies","title":"Terminologies","text":"<p>If you're new to Amazon CloudWatch, there are two terminologies you must be aware of before using this utility:</p> <ul> <li>Namespace. It's the highest level container that will group multiple metrics from multiple services for a given application, for example <code>ServerlessEcommerce</code>.</li> <li>Dimensions. Metrics metadata in key-value format. They help you slice and dice metrics visualization, for example <code>ColdStart</code> metric by Payment <code>service</code>.</li> <li>Metric. It's the name of the metric, for example: SuccessfulBooking or UpdatedBooking.</li> <li>Unit. It's a value representing the unit of measure for the corresponding metric, for example: Count or Seconds.</li> <li>Resolution. It's a value representing the storage resolution for the corresponding metric. Metrics can be either Standard or High resolution. Read more here.</li> </ul> <p>Visit the AWS documentation for a complete explanation for Amazon CloudWatch concepts.</p> Metric terminology, visually explained"},{"location":"core/metrics/#getting-started","title":"Getting started","text":"<p><code>Metrics</code> is implemented as a Singleton to keep track of your aggregate metrics in memory and make them accessible anywhere in your code. To guarantee that metrics are flushed properly the <code>MetricsAttribute</code> must be added on the lambda handler.</p> <p>Metrics has two global settings that will be used across all metrics emitted. Use your application or main service as the metric namespace to easily group all metrics:</p> Setting Description Environment variable Constructor parameter Service Optionally, sets service metric dimension across all metrics e.g. <code>payment</code> <code>POWERTOOLS_SERVICE_NAME</code> <code>Service</code> Metric namespace Logical container where all metrics will be placed e.g. <code>MyCompanyEcommerce</code> <code>POWERTOOLS_METRICS_NAMESPACE</code> <code>Namespace</code> <p>Autocomplete Metric Units</p> <p>All parameters in <code>Metrics Attribute</code> are optional. Following rules apply:</p> <ul> <li>Namespace: <code>Empty</code> string by default. You can either specify it in code or environment variable. If not present before flushing metrics, a <code>SchemaValidationException</code> will be thrown.</li> <li>Service: <code>service_undefined</code> by default. You can either specify it in code or environment variable.</li> <li>CaptureColdStart: <code>false</code> by default. </li> <li>RaiseOnEmptyMetrics: <code>false</code> by default.</li> </ul>"},{"location":"core/metrics/#example-using-aws-serverless-application-model-aws-sam","title":"Example using AWS Serverless Application Model (AWS SAM)","text":"template.ymlFunction.cs <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function Properties:\n...\nEnvironment: Variables:\nPOWERTOOLS_SERVICE_NAME: ShoppingCartService\nPOWERTOOLS_METRICS_NAMESPACE: MyCompanyEcommerce\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n[Metrics(Namespace = \"MyCompanyEcommerce\", Service = \"ShoppingCartService\", CaptureColdStart = true, RaiseOnEmptyMetrics = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre>"},{"location":"core/metrics/#full-list-of-environment-variables","title":"Full list of environment variables","text":"Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging <code>\"service_undefined\"</code> POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics <code>None</code>"},{"location":"core/metrics/#creating-metrics","title":"Creating metrics","text":"<p>You can create metrics using <code>AddMetric</code>, and you can create dimensions for all your aggregate metrics using <code>AddDimension</code> method.</p> MetricsMetrics with custom dimensions <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count);\n}\n}\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.AddDimension(\"Environment\",\"Prod\");\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count);\n}\n}\n</code></pre> <p>Autocomplete Metric Units</p> <p><code>MetricUnit</code> enum facilitates finding a supported metric unit by CloudWatch.</p> <p>Metrics overflow</p> <p>CloudWatch EMF supports a max of 100 metrics per batch. Metrics utility will flush all metrics when adding the 100th metric. Subsequent metrics, e.g. 101th, will be aggregated into a new EMF object, for your convenience.</p> <p>Metric value must be a positive number</p> <p>Metric values must be a positive number otherwise an <code>ArgumentException</code> will be thrown.</p> <p>Do not create metrics or dimensions outside the handler</p> <p>Metrics or dimensions added in the global scope will only be added during cold start. Disregard if that's the intended behavior.</p>"},{"location":"core/metrics/#adding-high-resolution-metrics","title":"Adding high-resolution metrics","text":"<p>You can create high-resolution metrics passing <code>MetricResolution</code> as parameter to <code>AddMetric</code>.</p> <p>When is it useful?</p> <p>High-resolution metrics are data with a granularity of one second and are very useful in several situations such as telemetry, time series, real-time incident management, and others.</p> Metrics with high resolution <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Publish a metric with standard resolution i.e. StorageResolution = 60\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count, MetricResolution.Standard);\n// Publish a metric with high resolution i.e. StorageResolution = 1\nMetrics.AddMetric(\"FailedBooking\", 1, MetricUnit.Count, MetricResolution.High);\n// The last parameter (storage resolution) is optional\nMetrics.AddMetric(\"SuccessfulUpgrade\", 1, MetricUnit.Count);\n}\n}\n</code></pre> <p>Autocomplete Metric Resolutions</p> <p>Use the <code>MetricResolution</code> enum to easily find a supported metric resolution by CloudWatch.</p>"},{"location":"core/metrics/#adding-default-dimensions","title":"Adding default dimensions","text":"<p>You can use <code>SetDefaultDimensions</code> method to persist dimensions across Lambda invocations.</p> SetDefaultDimensions method <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\nprivate Dictionary&lt;string, string&gt; _defaultDimensions = new Dictionary&lt;string, string&gt;{\n{\"Environment\", \"Prod\"},\n{\"Another\", \"One\"}\n}; [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.SetDefaultDimensions(_defaultDimensions);\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count);\n}\n}\n</code></pre>"},{"location":"core/metrics/#flushing-metrics","title":"Flushing metrics","text":"<p>With <code>MetricsAttribute</code> all your metrics are validated, serialized and flushed to standard output when lambda handler completes execution or when you had the 100th metric to memory.</p> <p>During metrics validation, if no metrics are provided then a warning will be logged, but no exception will be raised.</p> Function.csExample CloudWatch Logs excerpt <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count);\n}\n}\n</code></pre> <pre><code>{\n\"BookingConfirmation\": 1.0,\n\"_aws\": {\n\"Timestamp\": 1592234975665,\n\"CloudWatchMetrics\": [\n{\n\"Namespace\": \"ExampleApplication\",\n\"Dimensions\": [\n[\n\"service\"\n]\n],\n\"Metrics\": [\n{\n\"Name\": \"BookingConfirmation\",\n\"Unit\": \"Count\"\n}\n]\n}\n]\n},\n\"service\": \"ExampleService\"\n}\n</code></pre> <p>Metric validation</p> <p>If metrics are provided, and any of the following criteria are not met, <code>SchemaValidationException</code> will be raised:</p> <ul> <li>Maximum of 9 dimensions</li> <li>Namespace is set</li> <li>Metric units must be supported by CloudWatch</li> </ul> <p>We do not emit 0 as a value for ColdStart metric for cost reasons. Let us know if you'd prefer a flag to override it</p>"},{"location":"core/metrics/#raising-schemavalidationexception-on-empty-metrics","title":"Raising SchemaValidationException on empty metrics","text":"<p>If you want to ensure that at least one metric is emitted, you can pass <code>RaiseOnEmptyMetrics</code> to the Metrics attribute:</p> Function.cs <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(RaiseOnEmptyMetrics = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n  {\n    ...\n</code></pre>"},{"location":"core/metrics/#capturing-cold-start-metric","title":"Capturing cold start metric","text":"<p>You can optionally capture cold start metrics by setting <code>CaptureColdStart</code> parameter to <code>true</code>.</p> Function.cs <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(CaptureColdStart = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n</code></pre> <p>If it's a cold start invocation, this feature will:</p> <ul> <li>Create a separate EMF blob solely containing a metric named <code>ColdStart</code></li> <li>Add <code>function_name</code> and <code>service</code> dimensions</li> </ul> <p>This has the advantage of keeping cold start metric separate from your application metrics, where you might have unrelated dimensions.</p>"},{"location":"core/metrics/#advanced","title":"Advanced","text":""},{"location":"core/metrics/#adding-metadata","title":"Adding metadata","text":"<p>You can add high-cardinality data as part of your Metrics log with <code>AddMetadata</code> method. This is useful when you want to search highly contextual information along with your metrics in your logs.</p> <p>Info</p> <p>This will not be available during metrics visualization - Use dimensions for this purpose</p> Function.csExample CloudWatch Logs excerpt <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = ExampleApplication, Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count);\nMetrics.AddMetadata(\"BookingId\", \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\");\n...\n</code></pre> <pre><code>{\n\"SuccessfulBooking\": 1.0,\n\"_aws\": {\n\"Timestamp\": 1592234975665,\n\"CloudWatchMetrics\": [\n{\n\"Namespace\": \"ExampleApplication\",\n\"Dimensions\": [\n[\n\"service\"\n]\n],\n\"Metrics\": [\n{\n\"Name\": \"SuccessfulBooking\",\n\"Unit\": \"Count\"\n}\n]\n}\n]\n},\n\"Service\": \"Booking\",\n\"BookingId\": \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\"\n}\n</code></pre>"},{"location":"core/metrics/#single-metric-with-a-different-dimension","title":"Single metric with a different dimension","text":"<p>CloudWatch EMF uses the same dimensions across all your metrics. Use <code>PushSingleMetric</code> if you have a metric that should have different dimensions.</p> <p>Info</p> <p>Generally, this would be an edge case since you pay for unique metric. Keep the following formula in mind:</p> <p>unique metric = (metric_name + dimension_name + dimension_value)</p> Function.cs <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = ExampleApplication, Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.PushSingleMetric(\nmetricName: \"ColdStart\",\nvalue: 1,\nunit: MetricUnit.Count,\nnameSpace: \"ExampleApplication\",\nservice: \"Booking\",\ndefaultDimensions: new Dictionary&lt;string, string&gt;\n{\n{\"FunctionContext\", \"$LATEST\"}\n});\n...\n</code></pre>"},{"location":"core/tracing/","title":"Tracing","text":"<p>Powertools tracing is an opinionated thin wrapper for AWS X-Ray .NET SDK a provides functionality to reduce the overhead of performing common tracing tasks.</p> <p></p>"},{"location":"core/tracing/#key-features","title":"Key Features","text":"<ul> <li>Helper methods to improve the developer experience for creating custom AWS X-Ray subsegments.</li> <li>Capture cold start as annotation.</li> <li>Capture function responses and full exceptions as metadata.</li> <li>Better experience when developing with multiple threads.</li> <li>Auto-patch supported modules by AWS X-Ray</li> </ul>"},{"location":"core/tracing/#getting-started","title":"Getting Started","text":"<p>Before you use this utility, your AWS Lambda function must have permissions to send traces to AWS X-Ray.</p> <p>To enable active tracing on an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function resource, use the <code>Tracing</code> property. You can use the Globals section of the AWS SAM template to set this for all  </p>"},{"location":"core/tracing/#using-aws-serverless-application-model-aws-sam","title":"Using AWS Serverless Application Model (AWS SAM)","text":"template.yaml <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nRuntime: dotnet6.0\n\nTracing: Active\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: example\n</code></pre> <p>The Powertools service name is used as the X-Ray namespace. This can be set using the environment variable <code>POWERTOOLS_SERVICE_NAME</code></p>"},{"location":"core/tracing/#full-list-of-environment-variables","title":"Full list of environment variables","text":"Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging <code>\"service_undefined\"</code> POWERTOOLS_TRACE_DISABLED Disables tracing <code>false</code> POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. <code>true</code> POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. <code>true</code>"},{"location":"core/tracing/#lambda-handler","title":"Lambda handler","text":"<p>To enable Powertools tracing to your function add the <code>[Tracing]</code> attribute to your <code>FunctionHandler</code> method or on any method will capture the method as a separate subsegment automatically. You can optionally choose to customize segment name that appears in traces.</p> Tracing attributeCustom Segment names <pre><code>public class Function\n{\n[Tracing]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nawait BusinessLogic1()\n.ConfigureAwait(false);\n\nawait BusinessLogic2()\n.ConfigureAwait(false);\n}\n\n[Tracing]\nprivate async Task BusinessLogic1()\n{\n\n}\n\n[Tracing]\nprivate async Task BusinessLogic2()\n{\n\n}\n}\n</code></pre> <pre><code>public class Function\n{\n[Tracing(SegmentName = \"YourCustomName\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <p>By default, this attribute will automatically record method responses and exceptions. You can change the default behavior by setting the environment variables <code>POWERTOOLS_TRACER_CAPTURE_RESPONSE</code> and <code>POWERTOOLS_TRACER_CAPTURE_ERROR</code> as needed. Optionally, you can override behavior by different supported <code>CaptureMode</code> to record response, exception or both.</p> <p>Returning sensitive information from your Lambda handler or functions, where <code>Tracing</code> is used?</p> <p>You can disable attribute from capturing their responses and exception as tracing metadata with <code>captureMode=DISABLED</code> or globally by setting environment variables <code>POWERTOOLS_TRACER_CAPTURE_RESPONSE</code> and <code>POWERTOOLS_TRACER_CAPTURE_ERROR</code> to <code>false</code></p> Disable on attributeDisable Globally <pre><code>public class Function\n{\n[Tracing(CaptureMode = TracingCaptureMode.Disabled)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nRuntime: dotnetcore3.1\n\nTracing: Active\nEnvironment:\nVariables:\nPOWERTOOLS_TRACER_CAPTURE_RESPONSE: false\nPOWERTOOLS_TRACER_CAPTURE_ERROR: false\n</code></pre>"},{"location":"core/tracing/#annotations-metadata","title":"Annotations &amp; Metadata","text":"<p>Annotations are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions.</p> <p>Metadata are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional context for an operation using any native object.</p> AnnotationsMetadata <p>You can add annotations using <code>AddAnnotation()</code> method from Tracing <pre><code>using AWS.Lambda.Powertools.Tracing;\n\npublic class Function\n{\n[Tracing]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nTracing.AddAnnotation(\"annotation\", \"value\");\n}\n}\n</code></pre></p> <p>You can add metadata using <code>AddMetadata()</code> method from Tracing <pre><code>using AWS.Lambda.Powertools.Tracing;\n\npublic class Function\n{\n[Tracing]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nTracing.AddMetadata(\"content\", \"value\");\n}\n}\n</code></pre></p>"},{"location":"core/tracing/#utilities","title":"Utilities","text":"<p>Tracing modules comes with certain utility method when you don't want to use attribute for capturing a code block under a subsegment, or you are doing multithreaded programming. Refer examples below.</p> Functional ApiMulti Threaded Programming <pre><code>using AWS.Lambda.Powertools.Tracing;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nTracing.WithSubsegment(\"loggingResponse\", (subsegment) =&gt; {\n// Some business logic\n});\nTracing.WithSubsegment(\"localNamespace\", \"loggingResponse\", (subsegment) =&gt; {\n// Some business logic\n});\n}\n}\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Tracing;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Extract existing trace data\nvar entity = Tracing.GetEntity();\n\nvar task = Task.Run(() =&gt;\n{\nTracing.WithSubsegment(\"InlineLog\", entity, (subsegment) =&gt;\n{\n// Business logic in separate task\n});\n});\n}\n}\n</code></pre>"},{"location":"core/tracing/#instrumenting-sdk-clients-and-http-calls","title":"Instrumenting SDK clients and HTTP calls","text":"<p>User should make sure to instrument the SDK clients explicitly based on the function dependency. Refer details on how to instrument SDK client with Xray and outgoing http calls.</p>"}]}