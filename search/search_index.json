{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Powertools for AWS Lambda (.NET)","text":""},{"location":"#powertools-for-aws-lambda-net","title":"Powertools for AWS Lambda (.NET)","text":"<p>Powertools for AWS Lambda (.NET) (which from here will be referred as Powertools) is a suite of utilities for AWS Lambda functions to ease adopting best practices such as tracing, structured logging, custom metrics, and more. Please note, Powertools for AWS Lambda (.NET) is optimized for .NET 6+.</p> Tip <p>Powertools is also available for Python, Java, and TypeScript.</p> Support this project by becoming a reference customer or sharing your work  <p>You can choose to support us in three ways:</p> <p>1) Become a reference customers. This gives us permission to list your company in our documentation.</p> <p>2) Share your work. Blog posts, video, sample projects you used Powertools!</p>"},{"location":"#features","title":"Features","text":"<p>Core utilities such as Tracing, Logging, and Metrics will be available across all Powertools for AWS Lambda languages. Additional utilities are subjective to each language ecosystem and customer demand.</p> Utility Description Tracing Decorators and utilities to trace Lambda function handlers, and both synchronous and asynchronous functions Logger Structured logging made easier, and decorator to enrich structured logging with key Lambda context details Metrics Custom AWS metrics created asynchronously via CloudWatch Embedded Metric Format (EMF) Parameters (developer preview) provides high-level functionality to retrieve one or multiple parameter values from AWS Systems Manager Parameter Store, AWS Secrets Manager, or Amazon DynamoDB. We also provide extensibility to bring your own providers. Idempotency (developer preview) The idempotency utility provides a simple solution to convert your Lambda functions into idempotent operations which are safe to retry."},{"location":"#install","title":"Install","text":"<p>Powertools for AWS Lambda (.NET) is available as NuGet packages. You can install the packages from NuGet gallery or from Visual Studio editor. Search <code>AWS.Lambda.Powertools*</code> to see various utilities available.</p> <ul> <li> <p>AWS.Lambda.Powertools.Tracing:</p> <p><code>dotnet add package AWS.Lambda.Powertools.Tracing</code></p> </li> <li> <p>AWS.Lambda.Powertools.Logging:</p> <p><code>dotnet add package AWS.Lambda.Powertools.Logging</code></p> </li> <li> <p>AWS.Lambda.Powertools.Metrics:</p> <p><code>dotnet add package AWS.Lambda.Powertools.Metrics</code></p> </li> <li> <p>AWS.Lambda.Powertools.Parameters:</p> <p><code>dotnet add package AWS.Lambda.Powertools.Parameters</code></p> </li> <li> <p>AWS.Lambda.Powertools.Idempotency:</p> <p><code>dotnet add package AWS.Lambda.Powertools.Idempotency</code></p> </li> </ul>"},{"location":"#using-sam-cli-template","title":"Using SAM CLI template","text":"<p>We have provided you with a custom template for the Serverless Application Model (AWS SAM) command-line interface (CLI). This generates a starter project that allows you to interactively choose the Powertools for AWS Lambda (.NET) features that enables you to include in your project.</p> <p>To use the SAM CLI, you need the following tools.</p> <ul> <li>SAM CLI - Install the SAM CLI</li> <li>.NET 6.0 (LTS)  - Install .NET 6.0</li> <li>Docker - Install Docker community edition</li> </ul> <p>Once you have SAM CLI installed, follow the these steps to initialize a .NET 6 project using Powertools for AWS (.NET)</p> <ol> <li>Run the following command in your command line     <pre><code>sam init -r dotnet6\n</code></pre></li> <li> <p>Select option 1 as your template source</p> <p><pre><code>Which template source would you like to use?\n    1 - AWS Quick Start Templates\n    2 - Custom Template Location\n</code></pre> 3. Select the <code>Hello World Example with Powertools for AWS Lambda</code> template</p> <pre><code>Choose an AWS Quick Start application template\n    1 - Hello World Example\n    2 - Data processing\n    3 - Hello World Example with Powertools for AWS Lambda\n    4 - Multi-step workflow\n    5 - Scheduled task\n    6 - Standalone function\n    7 - Serverless API\nTemplate: 3\n</code></pre> </li> <li> <p>Follow the rest of the prompts and give your project a name</p> </li> </ol> <p>Viola! You now have a SAM application pre-configured with Powertools!</p>"},{"location":"#examples","title":"Examples","text":"<p>We have provided a few examples that should you how to use the each of the core Powertools for AWS Lambda (.NET) features.</p> <ul> <li>Tracing</li> <li>Logging</li> <li>Metrics</li> <li>Parameters</li> <li>Idempotency</li> </ul>"},{"location":"#connect","title":"Connect","text":"<ul> <li>Powertools for AWS Lambda (.NET) on Discord: <code>#dotnet</code> - Invite link</li> <li>Email: aws-lambda-powertools-feedback@amazon.com</li> </ul>"},{"location":"#tenets","title":"Tenets","text":"<p>These are our core principles to guide our decision making.</p> <ul> <li>AWS Lambda only. We optimize for AWS Lambda function environments and supported runtimes only. Utilities might work with web frameworks and non-Lambda environments, though they are not officially supported.</li> <li>Eases the adoption of best practices. The main priority of the utilities is to facilitate best practices adoption, as defined in the AWS Well-Architected Serverless Lens; all other functionality is optional.</li> <li>Keep it lean. Additional dependencies are carefully considered for security and ease of maintenance, and prevent negatively impacting startup time.</li> <li>We strive for backwards compatibility. New features and changes should keep backwards compatibility. If a breaking change cannot be avoided, the deprecation and migration process should be clearly defined.</li> <li>We work backwards from the community. We aim to strike a balance of what would work best for 80% of customers. Emerging practices are considered and discussed via Requests for Comment (RFCs)</li> <li>Idiomatic. Utilities follow programming language idioms and language-specific best practices.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. See Conventional Commits for commit guidelines.</p> <p></p>"},{"location":"changelog/#140-2023-06-21","title":"1.4.0 - 2023-06-21","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>update team name</li> <li>update references</li> <li>updated codeowners</li> <li>reapplying some lins that got screwed up in the merge</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>adding permission</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>docs: Start S3 Docs</li> </ul>"},{"location":"changelog/#maintenance","title":"Maintenance","text":"<ul> <li>updated code owners</li> <li>Change repo URL to the new location</li> <li>rename project to Powertools for AWS Lambda (.NET)</li> <li>ci: updated links to new repo</li> <li>ci: removed unnecessary areas</li> <li>docs: fix we made this link</li> <li>docs: update docs homepage with additional features, fixed dot cli commands, new SAM cli instructions</li> <li>docs: updated readme with idempotency package and examples for parameters and idempotency</li> <li>docs: move idempotency</li> </ul>"},{"location":"changelog/#pull-requests","title":"Pull Requests","text":"<ul> <li>Merge pull request #305 from aws-powertools/version-bump-1.4</li> <li>Merge pull request #301 from sliedig/sliedig-docs</li> <li>Merge pull request #302 from aws-powertools/rename-part2</li> <li>Merge pull request #291 from aws-powertools/doc-updates-roadmap</li> <li>Merge pull request #285 from aws-powertools/url-rename</li> <li>Merge pull request #293 from glynn1211/develop</li> <li>Merge pull request #163 from hossambarakat/feature/idempotency</li> <li>Merge pull request #282 from awslabs/rename</li> <li>Merge pull request #277 from awslabs/update-changelog-4981653012</li> <li>Merge pull request #274 from awslabs/dependabot/pip/pymdown-extensions-10.0</li> <li>Merge pull request #276 from awslabs/pymdown-extension-fix</li> <li>Merge pull request #278 from awslabs/s3-docs</li> <li>Merge pull request #273 from leandrodamascena/parameters/docs</li> <li>Merge pull request #271 from amirkaws/amirkaws-fix-parameters-nuget-icon</li> </ul>"},{"location":"changelog/#130-2023-05-12","title":"1.3.0 - 2023-05-12","text":""},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>fixed formatting and updated content</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>add package readme</li> </ul>"},{"location":"changelog/#maintenance_1","title":"Maintenance","text":"<ul> <li>ci: skip analytics on forks</li> </ul>"},{"location":"changelog/#pull-requests_1","title":"Pull Requests","text":"<ul> <li>Merge pull request #268 from amirkaws/amirkaws-release-version-1.3.0</li> <li>Merge pull request #167 from amirkaws/amirkaws-feature-parameters</li> <li>Merge pull request #1 from sliedig/amirkaws-feature-parameters</li> <li>Merge pull request #264 from awslabs/chore(ci)-skip-analytics-on-forks</li> <li>Merge pull request #262 from awslabs/chorebump-version-1.2.0-release</li> </ul>"},{"location":"changelog/#120-2023-05-05","title":"1.2.0 - 2023-05-05","text":""},{"location":"changelog/#pull-requests_2","title":"Pull Requests","text":"<ul> <li>Merge pull request #258 from amirkaws/amirkaws-release-version-1.2.0</li> <li>Merge pull request #226 from hjgraca/feat_support_high_resolution_metrics</li> </ul>"},{"location":"changelog/#110-2023-05-05","title":"1.1.0 - 2023-05-05","text":""},{"location":"changelog/#maintenance_2","title":"Maintenance","text":"<ul> <li>add Lambda Powertools for Python in issue templates</li> <li>add workflow to dispatch analytics fetching</li> <li>ci: add workflow to dispatch analytics fetching</li> </ul>"},{"location":"changelog/#pull-requests_3","title":"Pull Requests","text":"<ul> <li>Merge pull request #255 from awslabs/fix-remove-real-env-tests</li> <li>Merge pull request #253 from amirkaws/amirkaws-release-v1.1.0</li> <li>Merge pull request #246 from hjgraca/feat_set-execution-context</li> <li>Merge pull request #251 from leandrodamascena/issues-templates/python</li> <li>Merge pull request #241 from awslabs/update-changelog-4691350388</li> <li>Merge pull request #237 from hjgraca/changelog-update-pipeline</li> <li>Merge pull request #235 from amirkaws/amirkaws-update-examples-nuget-references-release-v1.0.1</li> </ul>"},{"location":"changelog/#v101-2023-04-06","title":"v1.0.1 - 2023-04-06","text":""},{"location":"changelog/#pull-requests_4","title":"Pull Requests","text":"<ul> <li>Merge pull request #232 from amirkaws/amirkaws-release-v1.0.1</li> <li>Merge pull request #227 from hjgraca/chore_fix_changelog_build</li> <li>Merge pull request #225 from srcsakthivel/develop</li> <li>Merge pull request #223 from hjgraca/fix_tracing_on_exception_thrown</li> <li>Merge pull request #218 from amirkaws/amirkaws-update-examples-nuget-references-release</li> </ul>"},{"location":"changelog/#v100-2023-02-24","title":"v1.0.0 - 2023-02-24","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>removing manual trigger on docs wf</li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>home: update powertools definition</li> </ul>"},{"location":"changelog/#maintenance_3","title":"Maintenance","text":"<ul> <li>ci: api docs build update (#188)</li> <li>ci: changing trigger to run manually</li> <li>ci: updated api docs implementation</li> <li>ci: updated bug report template</li> <li>deps: updates sample deps</li> <li>docs: incorrect crefs</li> </ul>"},{"location":"changelog/#pull-requests_5","title":"Pull Requests","text":"<ul> <li>Merge pull request #215 from amirkaws/amirkaws-release-v1.0.0</li> <li>Merge pull request #208 from amirkaws/amirkaws-cold-start-capture-warning-bug-fix</li> <li>Merge pull request #210 from awslabs/powertools-definition-update</li> <li>Merge pull request #209 from amirkaws/amirkaws-metrics-timestamp-fix</li> <li>Merge pull request #199 from awslabs/sliedig-ci-reviewers</li> <li>Merge pull request #193 from hjgraca/maintenance-new-issue-template</li> <li>Merge pull request #202 from hjgraca/fix-test-json-escaping</li> <li>Merge pull request #195 from hjgraca/update-dotnet-sdk-6.0.405</li> <li>Merge pull request #194 from hjgraca/patch-1</li> <li>Merge pull request #192 from hjgraca/fix-incorrect-crefs</li> <li>Merge pull request #189 from sliedig/develop</li> <li>Merge pull request #185 from amirkaws/amirkaws-update-examples-nuget-references</li> <li>Merge pull request #183 from awslabs/develop</li> <li>Merge pull request #150 from awslabs/develop</li> <li>Merge pull request #140 from awslabs/develop</li> </ul>"},{"location":"changelog/#v002-preview-2023-01-18","title":"v0.0.2-preview - 2023-01-18","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>removed duplicate template issue</li> <li>updated logger casing env vars in samples</li> </ul>"},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li>typo in metrics README</li> </ul>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>ci: codeql static code analysis (#148)</li> </ul>"},{"location":"changelog/#maintenance_4","title":"Maintenance","text":"<ul> <li>updated setup-dotnet@v1 to @v3</li> <li>updated packages (#172)</li> <li>ci: bumped version</li> <li>ci: minor updates, licensing</li> <li>deps: bump gitpython from 3.1.29 to 3.1.30</li> <li>docs: updated documentation (#175)</li> <li>docs: add discord invitation link</li> </ul>"},{"location":"changelog/#pull-requests_6","title":"Pull Requests","text":"<ul> <li>Merge pull request #182 from sliedig/develop</li> <li>Merge pull request #181 from awslabs/dependabot/pip/gitpython-3.1.30</li> <li>Merge pull request #179 from sliedig/sliedig-ci</li> <li>Merge pull request #174 from sliedig/sliedig-ci</li> <li>Merge pull request #173 from sliedig/sliedig-samples</li> <li>Merge pull request #157 from kenfdev/fix-readme-title-typo</li> <li>Merge pull request #170 from nCubed/develop</li> <li>Merge pull request #152 from amirkaws/amirkaws-custom-exception-json-converter</li> <li>Merge pull request #155 from sthuber90/add-discord-link-154</li> <li>Merge pull request #147 from amirkaws/amirkaws-fix-doc-links</li> </ul>"},{"location":"changelog/#v001-preview1-2022-08-01","title":"v0.0.1-preview.1 - 2022-08-01","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>force directy rename</li> <li>making test function compile.</li> <li>updating issue templates with correct extention</li> <li>updated auto assign</li> <li>skip duplicate nuget packages publish</li> <li>added missing runtimes</li> <li>updated Logging template description</li> <li>updated documentation and doc generation (#96)</li> <li>removed optional doc file paths</li> <li>explicitly adding doc files for build configurations</li> <li>resolving dependecy alert CVE-2020-8116</li> <li>added missing codecov packages for test projects</li> <li>fixed build</li> <li>forcing rename</li> <li>fixed powertolls spelling in docs</li> <li>replaced PackageIconUrl which is being depreciated with PackageIcon</li> <li>added missing include to pack README files</li> <li>fixing node vulnerabilites for docs</li> <li>resolving merge conflict</li> <li>update packages to resolve vulnerabilities. Switched to yarn package manager</li> <li>intermin fix to resolve vulnerability issues.</li> <li>proj references</li> <li>fixed spelling in libraries folder name</li> <li>ci: lockdown gh-pages workflow to sha</li> </ul>"},{"location":"changelog/#documentation_4","title":"Documentation","text":"<ul> <li>fixed nav for roadmap</li> <li>updated link to feature request; added roadmap</li> <li>library readme updates and minor updates  (#117)</li> <li>spell check with US-English dictionary (#115)</li> <li>docs review (#112)</li> <li>Reviewing documentation (#68)</li> <li>adding auto-generated API Reference to docs (#87)</li> <li>alternative brew installation (#86)</li> <li>homebrew installation (#85)</li> <li>merging api generation tasks (#84)</li> <li>fixing docfx path (#83)</li> <li>fix docfx path (#82)</li> <li>fix api docs generator installation (#81)</li> <li>update github actions to publish api docs (#80)</li> <li>API docs generation (#79)</li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>added security.md</li> <li>updated record_pr action</li> <li>PR Labeler GitHub actions (#119)</li> <li>Logger output case attributes docs and unit testing (#100)</li> <li>add extra fields to the logger methods (#98)</li> <li>updated examples to include managed runtime configuration as well as docker. Made updates to Tracing implementation</li> <li>added Tracing example</li> <li>added init Metrics sample</li> <li>added Logging example</li> <li>added serialisation options to force dictionary keys to camel case</li> <li>added build tools to generate nuget packages</li> <li>updated project packaging properties</li> <li>added package README files for core utilities</li> <li>update make and doc dep to build docs</li> <li>added docs template</li> </ul>"},{"location":"changelog/#maintenance_5","title":"Maintenance","text":"<ul> <li>set global .net version</li> <li>temporarily removing docs while content is being developed</li> <li>added example project</li> <li>refctored PowerTools to Powertools</li> <li>added github files and templates</li> <li>initial folder structure</li> <li>interim resolution of docs package vulnerabilities</li> <li>migrated AWS.Lambda.PowerTools to AWS.Lambda.PowerTools.Common namespace. fix: resolved incorrect namespace for Tracing fix: resolved dependencies in example project</li> <li>refactored to new namespace</li> <li>updated readme</li> <li>updated github templates</li> <li>added customer 404 page</li> <li>removing unecessary buildtools</li> <li>update pr template</li> <li>updating type documentation and file headers (#56)</li> <li>moved solution file into libraries. Need a separate solution for examples</li> <li>added docs</li> <li>added gitignore and updated licence</li> <li>updating doc build workflow</li> <li>updated issue templates</li> <li>updated Label PR based on title action</li> <li>deleted unnecessay publishing action</li> <li>updated stale action</li> <li>removed unnecessary pr labeling</li> <li>updated PR labeling path</li> <li>updated list of assignees</li> <li>updated docker builds to use Amazon.Lambda.Tools (#118)</li> <li>bumped .net version in global to 6.0.301 (#120)</li> <li>bumped .net version in global to 6.0.301</li> <li>adding missed copyright info</li> <li>added copyright to examples</li> <li>removed SimpleLambda from examples</li> <li>cleaned up logging and metrics functions</li> <li>ci: add on_merge_pr workflow to notify releases</li> <li>ci: lockdown untrusted workflows to sha</li> <li>ci: add missing scripts</li> <li>ci: updated bug report template (#144)</li> <li>ci: add workflow to detect missing related issue</li> <li>ci: enable concurrency group for docs workflow</li> <li>ci: upudated wording in PR template checklist</li> <li>ci: added codeowners</li> <li>ci: added Maintainers doc</li> <li>ci: updated PR workflows and scripts</li> <li>ci: upgrade setup-python to v4</li> <li>ci: upgrade checkout action to v3</li> <li>ci: use untrusted workflows with sha</li> <li>ci: add reusable export pr workflow dependency</li> <li>deps: bump hosted-git-info from 2.8.8 to 2.8.9 in /docs</li> <li>deps: bump object-path from 0.11.4 to 0.11.5 in /docs</li> <li>deps: bump ssri from 6.0.1 to 6.0.2 in /docs</li> <li>deps: bump elliptic from 6.5.3 to 6.5.4 in /docs</li> <li>deps: bump socket.io from 2.3.0 to 2.4.1 in /docs</li> <li>deps: bump ini from 1.3.5 to 1.3.8 in /docs</li> <li>deps: bump ua-parser-js from 0.7.23 to 0.7.28 in /docs</li> <li>deps: bump underscore from 1.12.0 to 1.13.1 in /docs</li> <li>deps: bump url-parse from 1.4.7 to 1.5.1 in /docs</li> <li>deps: bump prismjs from 1.20.0 to 1.21.0 in /docs</li> <li>deps: updates sample deps (#142)</li> <li>deps: bump mkdocs from 1.2.2 to 1.2.3 (#29)</li> <li>governance: render debug logs with csharp syntax</li> <li>governance: typo in pending release label name</li> </ul>"},{"location":"changelog/#pull-requests_7","title":"Pull Requests","text":"<ul> <li>Merge pull request #139 from awslabs/amirkaws-resolve-conflicts-2</li> <li>Merge pull request #135 from awslabs/amirkaws-update-versions</li> <li>Merge pull request #134 from heitorlessa/chore/lockdown-gh-pages-workflow</li> <li>Merge pull request #132 from heitorlessa/chore/github-concurrency-docs</li> <li>Merge pull request #130 from heitorlessa/chore/enforce-github-actions-sha</li> <li>Merge pull request #128 from sliedig/sliedig-ci</li> <li>Merge pull request #127 from sliedig/sliedig-ci</li> <li>Merge pull request #126 from sliedig/develop</li> <li>Merge pull request #123 from sliedig/develop</li> <li>Merge pull request #1 from sliedig/sliedig/develop</li> <li>Merge pull request #121 from awslabs/amirkaws-update-versions</li> <li>Merge pull request #116 from awslabs/amirkaws/add-di-support-for-logging</li> <li>Merge pull request #113 from awslabs/amirkaws/update-doc-1</li> <li>Merge pull request #111 from awslabs/amirkaws/add-env-vars-docs</li> <li>Merge pull request #102 from sliedig/sliedig/examples</li> <li>Merge pull request #103 from awslabs/amirkaws/fix-example-issues</li> <li>Merge pull request #97 from sliedig/sliedig/examples</li> <li>Merge pull request #95 from awslabs/pr/91</li> <li>Merge pull request #90 from sliedig/develop</li> <li>Merge pull request #89 from awslabs/api-docs-template</li> <li>Merge pull request #74 from awslabs/amirkaws/disable-tracing-outside-lambda-env</li> <li>Merge pull request #66 from sliedig/develop</li> <li>Merge pull request #59 from sliedig/develop</li> <li>Merge pull request #58 from sliedig/sliedig/nuget</li> <li>Merge pull request #32 from awslabs/amirkaws/metrics-1</li> <li>Merge pull request #31 from t1agob/develop</li> <li>Merge pull request #2 from awslabs/develop</li> <li>Merge pull request #25 from t1agob/develop</li> <li>Merge pull request #1 from t1agob/sourcegenerators</li> <li>Merge pull request #24 from sliedig/develop</li> <li>Merge pull request #23 from sliedig/develop</li> <li>Merge pull request #22 from sliedig/develop</li> <li>Merge pull request #21 from t1agob/develop</li> <li>Merge pull request #19 from awslabs/dependabot/npm_and_yarn/docs/url-parse-1.5.1</li> <li>Merge pull request #18 from awslabs/dependabot/npm_and_yarn/docs/hosted-git-info-2.8.9</li> <li>Merge pull request #17 from awslabs/dependabot/npm_and_yarn/docs/ua-parser-js-0.7.28</li> <li>Merge pull request #16 from awslabs/dependabot/npm_and_yarn/docs/underscore-1.13.1</li> <li>Merge pull request #15 from awslabs/dependabot/npm_and_yarn/docs/ssri-6.0.2</li> <li>Merge pull request #14 from awslabs/dependabot/npm_and_yarn/docs/elliptic-6.5.4</li> <li>Merge pull request #13 from sliedig/develop</li> <li>Merge pull request #12 from sliedig/develop</li> <li>Merge pull request #11 from awslabs/dependabot/npm_and_yarn/docs/socket.io-2.4.1</li> <li>Merge pull request #10 from awslabs/dependabot/npm_and_yarn/docs/ini-1.3.8</li> <li>Merge pull request #9 from awslabs/dependabot/npm_and_yarn/docs/object-path-0.11.5</li> <li>Merge pull request #7 from t1agob/develop</li> <li>Merge pull request #8 from sliedig/develop</li> <li>Merge pull request #5 from sliedig/develop</li> <li>Merge pull request #4 from sliedig/develop</li> <li>Merge pull request #3 from sliedig/develop</li> <li>Merge pull request #2 from awslabs/dependabot/npm_and_yarn/docs/prismjs-1.21.0</li> <li>Merge pull request #1 from sliedig/develop</li> </ul>"},{"location":"references/","title":"Powertools for AWS Lambda (.NET) references","text":""},{"location":"references/#environment-variables","title":"Environment variables","text":"<p>Info</p> <p>Explicit parameters take precedence over environment variables.</p> Environment variable Description Utility Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging All <code>\"service_undefined\"</code> POWERTOOLS_LOG_LEVEL Sets logging level Logging <code>Information</code> POWERTOOLS_LOGGER_CASE Override the default casing for log keys Logging <code>SnakeCase</code> POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event Logging <code>false</code> POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling Logging <code>0</code> POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics Metrics <code>None</code> POWERTOOLS_TRACE_DISABLED Disables tracing Tracing <code>false</code> POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. Tracing <code>true</code> POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. Tracing <code>true</code>"},{"location":"references/#sam-template-snippets","title":"SAM template snippets","text":""},{"location":"references/#logging","title":"Logging","text":"<pre><code># Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: MIT-0\nAWSTemplateFormatVersion: \"2010-09-09\"\nTransform: AWS::Serverless-2016-10-31\nDescription: &gt;\nExample project for Powertools for AWS Lambda (.NET) Logging utility\n\n# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst\nGlobals:\nFunction:\nTimeout: 10\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: powertools-dotnet-logging-sample\nPOWERTOOLS_LOG_LEVEL: Debug\nPOWERTOOLS_LOGGER_LOG_EVENT: true\nPOWERTOOLS_LOGGER_CASE: PascalCase # Allowed values are: CamelCase, PascalCase and SnakeCase\nPOWERTOOLS_LOGGER_SAMPLE_RATE: 0\n</code></pre>"},{"location":"references/#metrics","title":"Metrics","text":"<pre><code># Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: MIT-0\nAWSTemplateFormatVersion: \"2010-09-09\"\nTransform: AWS::Serverless-2016-10-31\nDescription: &gt;\nExample project for Powertools for AWS Lambda (.NET) Metrics utility\n\n# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst\nGlobals:\nFunction:\nTimeout: 10\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: powertools-dotnet-metrics-sample # This can also be set using the Metrics decorator on your handler [Metrics(Namespace = \"aws-lambda-powertools\"]\nPOWERTOOLS_METRICS_NAMESPACE: AWSLambdaPowertools # This can also be set using the Metrics decorator on your handler [Metrics(Namespace = \"aws-lambda-powertools\"]\n</code></pre>"},{"location":"references/#tracing","title":"Tracing","text":"<pre><code># Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: MIT-0\nAWSTemplateFormatVersion: \"2010-09-09\"\nTransform: AWS::Serverless-2016-10-31\nDescription: &gt;\nExample project for Powertools for AWS Lambda (.NET) tracing utility\n\n# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst\nGlobals:\nFunction:\nTimeout: 10\nTracing: Active\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: powertools-dotnet-tracing-sample\nPOWERTOOLS_TRACE_DISABLED: true\nPOWERTOOLS_TRACER_CAPTURE_RESPONSE: true\nPOWERTOOLS_TRACER_CAPTURE_ERROR: true     # To disable tracing (CaptureMode = TracingCaptureMode.Disabled)\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#overview","title":"Overview","text":"<p>This is our public roadmap that outlines the high level direction we are working towards, namely Themes. We update this document when our priorities change: security and stability is our top priority.</p> <p>See our latest list of activities \u00bb</p>"},{"location":"roadmap/#themes","title":"Themes","text":"<p>Operational Excellence is priority number 1.</p> <p>Themes are key activities maintainers are focusing on, besides bug reports. These are updated periodically and you can get an idea of the overall progress in the Milestones section.</p>"},{"location":"roadmap/#new-utilities","title":"New utilities","text":"<p>After going GA, we want to start working on new utilities, specifically but not limited to the most commonly asked: (1) Idempotency, (2) Parameters and (3) Batch.</p>"},{"location":"roadmap/#improve-operational-excellence","title":"Improve operational excellence","text":"<p>We continue to work on increasing operational excellence to remove as much undifferentiated heavylifting for maintainers, so that we can focus on delivering features that help you.</p> <p>This means improving our automation workflows, and project management, and test coverage.</p>"},{"location":"roadmap/#roadmap-status-definition","title":"Roadmap status definition","text":"<p> <pre><code>graph LR\n    Ideas --&gt; Backlog --&gt; Work[\"Working on it\"] --&gt; Merged[\"Coming soon\"] --&gt; Shipped\n</code></pre> Visual representation </p> <p>Within our public board, you'll see the following values in the <code>Status</code> column:</p> <ul> <li>Ideas. Incoming and existing feature requests that are not being actively considered yet. These will be reviewed when bandwidth permits and based on demand.</li> <li>Backlog. Accepted feature requests or enhancements that we want to work on.</li> <li>Working on it. Features or enhancements we're currently either researching or implementing it.</li> <li>Coming soon. Any feature, enhancement, or bug fixes that have been merged and are coming in the next release.</li> <li>Shipped. Features or enhancements that are now available in the most recent release.</li> <li>On hold. Features or items that are currently blocked until further notice.</li> <li>Pending review. Features which implementation is mostly completed, but need review and some additional iterations.</li> </ul> <p>Tasks or issues with empty <code>Status</code> will be categorized in upcoming review cycles.</p>"},{"location":"roadmap/#process","title":"Process","text":"<p> <pre><code>graph LR\n    PFR[Feature request] --&gt; Triage{Need RFC?}\n    Triage --&gt; |Complex/major change or new utility?| RFC[Ask or write RFC] --&gt; Approval{Approved?}\n    Triage --&gt; |Minor feature or enhancement?| NoRFC[No RFC required] --&gt; Approval\n    Approval --&gt; |Yes| Backlog\n    Approval --&gt; |No | Reject[\"Inform next steps\"]\n    Backlog --&gt; |Prioritized| Implementation\n    Backlog --&gt; |Defer| WelcomeContributions[\"help-wanted label\"]\n</code></pre> Visual representation </p> <p>Our end-to-end mechanism follows four major steps:</p> <ul> <li>Feature Request. Ideas start with a feature request to outline their use case at a high level. For complex use cases, maintainers might ask for/write a RFC.<ul> <li>Maintainers review requests based on project tenets, customers reaction (\ud83d\udc4d), and use cases.</li> </ul> </li> <li>Request-for-comments (RFC). Design proposals use our RFC issue template to describe its implementation, challenges, developer experience, dependencies, and alternative solutions.<ul> <li>This helps refine the initial idea with community feedback before a decision is made.</li> </ul> </li> <li>Decision. After carefully reviewing and discussing them, maintainers make a final decision on whether to start implementation, defer or reject it, and update everyone with the next steps.</li> <li>Implementation. For approved features, maintainers give priority to the original authors for implementation unless it is a sensitive task that is best handled by maintainers.</li> </ul> See Maintainers document to understand how we triage issues and pull requests, labels and governance."},{"location":"roadmap/#disclaimer","title":"Disclaimer","text":"<p>The Powertools for AWS Lambda team values feedback and guidance from its community of users, although final decisions on inclusion into the project will be made by AWS.</p> <p>We determine the high-level direction for our open roadmap based on customer feedback and popularity (\ud83d\udc4d\ud83c\udffd and comments), security and operational impacts, and business value. Where features don\u2019t meet our goals and longer-term strategy, we will communicate that clearly and openly as quickly as possible with an explanation of why the decision was made.</p>"},{"location":"roadmap/#faqs","title":"FAQs","text":"<p>Q: Why did you build this?</p> <p>A: We know that our customers are making decisions and plans based on what we are developing, and we want to provide our customers the insights they need to plan.</p> <p>Q: Why are there no dates on your roadmap?</p> <p>A: Because job zero is security and operational stability, we can't provide specific target dates for features. The roadmap is subject to change at any time, and roadmap issues in this repository do not guarantee a feature will be launched as proposed.</p> <p>Q: How can I provide feedback or ask for more information?</p> <p>A: For existing features, you can directly comment on issues. For anything else, please open an issue.</p>"},{"location":"tenets/","title":"Powertools for AWS Lambda (.NET) (developer preview)","text":"<p>Core utilities such as Tracing, Logging, Metrics, and Event Handler will be available across all Powertools for AWS Lambda runtimes. Additional utilities are subjective to each language ecosystem and customer demand.</p> <ul> <li>AWS Lambda only. We optimize for AWS Lambda function environments and supported runtimes only. Utilities might work with web frameworks and non-Lambda environments, though they are not officially supported.</li> <li>Eases the adoption of best practices. The main priority of the utilities is to facilitate best practices adoption, as defined in the AWS Well-Architected Serverless Lens; all other functionality is optional.</li> <li>Keep it lean. Additional dependencies are carefully considered for security and ease of maintenance, and prevent negatively impacting startup time.</li> <li>We strive for backwards compatibility. New features and changes should keep backwards compatibility. If a breaking change cannot be avoided, the deprecation and migration process should be clearly defined.</li> <li>We work backwards from the community. We aim to strike a balance of what would work best for 80% of customers. Emerging practices are considered and discussed via Requests for Comment (RFCs)</li> <li>Idiomatic. Utilities follow programming language idioms and language-specific best practices.</li> </ul>"},{"location":"we_made_this/","title":"We Made This (Community)","text":"<p>This space is dedicated to highlight our awesome community content featuring Powertools for AWS Lambda (.NET) \ud83d\ude4f!</p> <p>Get your content featured here!</p>"},{"location":"we_made_this/#connect","title":"Connect","text":"<p>Join us on Discord to connect with the Powertools for AWS Lambda community \ud83d\udc4b. Ask questions, learn from each other, contribute, hang out with key contributors, and more!</p>"},{"location":"core/logging/","title":"Logging","text":"<p>The logging utility provides a Lambda optimized logger with output structured as JSON.</p>"},{"location":"core/logging/#key-features","title":"Key features","text":"<ul> <li>Capture key fields from Lambda context, cold start and structures logging output as JSON</li> <li>Log Lambda event when instructed (disabled by default)</li> <li>Log sampling enables DEBUG log level for a percentage of requests (disabled by default)</li> <li>Append additional keys to structured log at any point in time</li> </ul>"},{"location":"core/logging/#installation","title":"Installation","text":"<p>Powertools for AWS Lambda (.NET) are available as NuGet packages. You can install the packages from NuGet Gallery or from Visual Studio editor by searching <code>AWS.Lambda.Powertools*</code> to see various utilities available.</p> <ul> <li> <p>AWS.Lambda.Powertools.Logging:</p> <p><code>dotnet add package AWS.Lambda.Powertools.Logging</code></p> </li> </ul>"},{"location":"core/logging/#getting-started","title":"Getting started","text":"<p>Logging requires two settings:</p> Setting Description Environment variable Attribute parameter Service Sets Service key that will be present across all log statements <code>POWERTOOLS_SERVICE_NAME</code> <code>Service</code> Logging level Sets how verbose Logger should be (Information, by default) <code>POWERTOOLS_LOG_LEVEL</code> <code>LogLevel</code>"},{"location":"core/logging/#example-using-aws-serverless-application-model-aws-sam","title":"Example using AWS Serverless Application Model (AWS SAM)","text":"<p>You can override log level by setting <code>POWERTOOLS_LOG_LEVEL</code> environment variable in the AWS SAM template.</p> <p>You can also explicitly set a service name via <code>POWERTOOLS_SERVICE_NAME</code> environment variable. This sets Service key that will be present across all log statements.</p> <p>Here is an example using the AWS SAM Globals section.</p> template.yaml <pre><code># Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: MIT-0\nAWSTemplateFormatVersion: \"2010-09-09\"\nTransform: AWS::Serverless-2016-10-31\nDescription: &gt;\nExample project for Powertools for AWS Lambda (.NET) Logging utility\n\nGlobals:\nFunction:\nTimeout: 10\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: powertools-dotnet-logging-sample\nPOWERTOOLS_LOG_LEVEL: Debug\nPOWERTOOLS_LOGGER_LOG_EVENT: true\nPOWERTOOLS_LOGGER_CASE: PascalCase # Allowed values are: CamelCase, PascalCase and SnakeCase\nPOWERTOOLS_LOGGER_SAMPLE_RATE: 0\n</code></pre>"},{"location":"core/logging/#full-list-of-environment-variables","title":"Full list of environment variables","text":"Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging <code>\"service_undefined\"</code> POWERTOOLS_LOG_LEVEL Sets logging level <code>Information</code> POWERTOOLS_LOGGER_CASE Override the default casing for log keys <code>SnakeCase</code> POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event <code>false</code> POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling <code>0</code>"},{"location":"core/logging/#standard-structured-keys","title":"Standard structured keys","text":"<p>Your logs will always include the following keys to your structured logging:</p> Key Type Example Description Timestamp string \"2020-05-24 18:17:33,774\" Timestamp of actual log statement Level string \"Information\" Logging level Name string \"Powertools for AWS Lambda (.NET) Logger\" Logger name ColdStart bool true ColdStart value. Service string \"payment\" Service name defined. \"service_undefined\" will be used if unknown SamplingRate int 0.1 Debug logging sampling rate in percentage e.g. 10% in this case Message string \"Collecting payment\" Log statement value. Unserializable JSON values will be cast to string FunctionName string \"example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" FunctionVersion string \"12\" FunctionMemorySize string \"128\" FunctionArn string \"arn:aws:lambda:eu-west-1:012345678910:function:example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" XRayTraceId string \"1-5759e988-bd862e3fe1be46a994272793\" X-Ray Trace ID when Lambda function has enabled Tracing FunctionRequestId string \"899856cb-83d1-40d7-8611-9e78f15f32f4\" AWS Request ID from lambda context"},{"location":"core/logging/#logging-incoming-event","title":"Logging incoming event","text":"<p>When debugging in non-production environments, you can instruct Logger to log the incoming event with <code>LogEvent</code> parameter or via <code>POWERTOOLS_LOGGER_LOG_EVENT</code> environment variable.</p> <p>Warning</p> <p>Log event is disabled by default to prevent sensitive info being logged.</p> Function.cs <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(LogEvent = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre>"},{"location":"core/logging/#setting-a-correlation-id","title":"Setting a Correlation ID","text":"<p>You can set a Correlation ID using <code>CorrelationIdPath</code> parameter by passing a JSON Pointer expression.</p> Function.csExample EventExample CloudWatch Logs excerpt <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(CorrelationIdPath = \"/headers/my_request_id_header\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <pre><code>{\n\"headers\": {\n\"my_request_id_header\": \"correlation_id_value\"\n}\n}\n</code></pre> <pre><code>{\n\"cold_start\": true,\n\"xray_trace_id\": \"1-61b7add4-66532bb81441e1b060389429\",\n\"function_name\": \"test\",\n\"function_version\": \"$LATEST\",\n\"function_memory_size\": 128,\n\"function_arn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"function_request_id\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"level\": \"Information\",\n\"service\": \"lambda-example\",\n\"name\": \"AWS.Lambda.Powertools.Logging.Logger\",\n\"message\": \"Collecting payment\",\n\"sampling_rate\": 0.7,\n\"correlation_id\": \"correlation_id_value\",\n}\n</code></pre> <p>We provide built-in JSON Pointer expression for known event sources, where either a request ID or X-Ray Trace ID are present.</p> Function.csExample EventExample CloudWatch Logs excerpt <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(CorrelationIdPath = CorrelationIdPaths.API_GATEWAY_REST)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <pre><code>{\n\"RequestContext\": {\n\"RequestId\": \"correlation_id_value\"\n}\n}\n</code></pre> <pre><code>{\n\"cold_start\": true,\n\"xray_trace_id\": \"1-61b7add4-66532bb81441e1b060389429\",\n\"function_name\": \"test\",\n\"function_version\": \"$LATEST\",\n\"function_memory_size\": 128,\n\"function_arn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"function_request_id\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"level\": \"Information\",\n\"service\": \"lambda-example\",\n\"name\": \"AWS.Lambda.Powertools.Logging.Logger\",\n\"message\": \"Collecting payment\",\n\"sampling_rate\": 0.7,\n\"correlation_id\": \"correlation_id_value\",\n}\n</code></pre>"},{"location":"core/logging/#appending-additional-keys","title":"Appending additional keys","text":"<p>Custom keys are persisted across warm invocations<p>Always set additional keys as part of your handler to ensure they have the latest value, or explicitly clear them with <code>ClearState=true</code>.</p> </p> <p>You can append your own keys to your existing logs via <code>AppendKey</code>. Typically this value would be passed into the function via the event. Appended keys are added to all subsequent log entries in the current execution from the point the logger method is called. To ensure the key is added to all log entries, call this method as early as possible in the Lambda handler.</p> Function.csExample CloudWatch Logs excerpt <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(LogEvent = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigwProxyEvent,\nILambdaContext context)\n{\nvar requestContextRequestId = apigwProxyEvent.RequestContext.RequestId;\n\nvar lookupInfo = new Dictionary&lt;string, object&gt;()\n{\n{\"LookupInfo\", new Dictionary&lt;string, object&gt;{{ \"LookupId\", requestContextRequestId }}}\n};  // Appended keys are added to all subsequent log entries in the current execution.\n// Call this method as early as possible in the Lambda handler.\n// Typically this is value would be passed into the function via the event.\n// Set the ClearState = true to force the removal of keys across invocations,\nLogger.AppendKeys(lookupInfo);\nLogger.LogInformation(\"Getting ip address from external service\");\n\n}\n</code></pre> <pre><code>{\n\"cold_start\": false,\n\"xray_trace_id\": \"1-622eede0-647960c56a91f3b071a9fff1\",\n\"lookup_info\": {\n\"lookup_id\": \"4c50eace-8b1e-43d3-92ba-0efacf5d1625\"\n},\n\"function_name\": \"PowertoolsLoggingSample-HelloWorldFunction-hm1r10VT3lCy\",\n\"function_version\": \"$LATEST\",\n\"function_memory_size\": 256,\n\"function_arn\": \"arn:aws:lambda:ap-southeast-2:538510314095:function:PowertoolsLoggingSample-HelloWorldFunction-hm1r10VT3lCy\",\n\"function_request_id\": \"96570b2c-f00e-471c-94ad-b25e95ba7347\",\n\"timestamp\": \"2022-03-14T07:25:20.9418065Z\",\n\"level\": \"Information\",\n\"service\": \"powertools-dotnet-logging-sample\",\n\"name\": \"AWS.Lambda.Powertools.Logging.Logger\",\n\"message\": \"Getting ip address from external service\"\n}\n</code></pre>"},{"location":"core/logging/#removing-additional-keys","title":"Removing additional keys","text":"<p>You can remove any additional key from entry using <code>Logger.RemoveKeys()</code>.</p> Function.cs <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(LogEvent = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\nLogger.AppendKey(\"test\", \"willBeLogged\");\n...\nvar customKeys = new Dictionary&lt;string, string&gt;\n{\n{\"test1\", \"value1\"}, {\"test2\", \"value2\"}\n};\n\nLogger.AppendKeys(customKeys);\n...\nLogger.RemoveKeys(\"test\");\nLogger.RemoveKeys(\"test1\", \"test2\");\n...\n}\n}\n</code></pre>"},{"location":"core/logging/#extra-keys","title":"Extra Keys","text":"<p>Extra keys allow you to append additional keys to a log entry. Unlike <code>AppendKey</code>, extra keys will only apply to the current log entry.</p> <p>Extra keys argument is available for all log levels' methods, as implemented in the standard logging library - e.g. Logger.Information, Logger.Warning.</p> <p>It accepts any dictionary, and all keyword arguments will be added as part of the root structure of the logs for that log statement.</p> <p>Info<p>Any keyword argument added using extra keys will not be persisted for subsequent messages.</p> </p> Function.cs <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(LogEvent = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigwProxyEvent,\nILambdaContext context)\n{\nvar requestContextRequestId = apigwProxyEvent.RequestContext.RequestId;\n\nvar lookupId = new Dictionary&lt;string, object&gt;()\n{\n{ \"LookupId\", requestContextRequestId }\n};\n// Appended keys are added to all subsequent log entries in the current execution.\n// Call this method as early as possible in the Lambda handler.\n// Typically this is value would be passed into the function via the event.\n// Set the ClearState = true to force the removal of keys across invocations,\nLogger.AppendKeys(lookupId);\n}\n</code></pre>"},{"location":"core/logging/#clearing-all-state","title":"Clearing all state","text":"<p>Logger is commonly initialized in the global scope. Due to Lambda Execution Context reuse, this means that custom keys can be persisted across invocations. If you want all custom keys to be deleted, you can use <code>ClearState=true</code> attribute on <code>[Logging]</code> attribute.</p> Function.cs#1 Request#2 Request <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(ClearState = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\nif (apigProxyEvent.Headers.ContainsKey(\"SomeSpecialHeader\"))\n{\nLogger.AppendKey(\"SpecialKey\", \"value\");\n}\n\nLogger.LogInformation(\"Collecting payment\");\n...\n}\n}\n</code></pre> <pre><code>{\n\"level\": \"Information\",\n\"message\": \"Collecting payment\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"service\": \"payment\",\n\"cold_start\": true,\n\"function_name\": \"test\",\n\"function_memory_size\": 128,\n\"function_arn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"function_request_id\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\",\n\"special_key\": \"value\"\n}\n</code></pre> <pre><code>{\n\"level\": \"Information\",\n\"message\": \"Collecting payment\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"service\": \"payment\",\n\"cold_start\": true,\n\"function_name\": \"test\",\n\"function_memory_size\": 128,\n\"function_arn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"function_request_id\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\"\n}\n</code></pre>"},{"location":"core/logging/#sampling-debug-logs","title":"Sampling debug logs","text":"<p>You can dynamically set a percentage of your logs to DEBUG level via env var <code>POWERTOOLS_LOGGER_SAMPLE_RATE</code> or via <code>SamplingRate</code> parameter on attribute.</p> <p>Info</p> <p>Configuration on environment variable is given precedence over sampling rate configuration on attribute, provided it's in valid value range.</p> Sampling via attribute parameterSampling via environment variable <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(SamplingRate = 0.5)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nEnvironment:\nVariables:\nPOWERTOOLS_LOGGER_SAMPLE_RATE: 0.5\n</code></pre>"},{"location":"core/logging/#configure-log-output-casing","title":"Configure Log Output Casing","text":"<p>By definition Powertools for AWS Lambda (.NET) outputs logging keys using snake case (e.g. \"function_memory_size\": 128). This allows developers using different Powertools for AWS Lambda (.NET) runtimes, to search logs across services written in languages such as Python or TypeScript.</p> <p>If you want to override the default behavior you can either set the desired casing through attributes, as described in the example below, or by setting the <code>POWERTOOLS_LOGGER_CASE</code> environment variable on your AWS Lambda function. Allowed values are: <code>CamelCase</code>, <code>PascalCase</code> and <code>SnakeCase</code>.</p> Output casing via attribute parameter <pre><code>/**\n * Handler for requests to Lambda function.\n */\npublic class Function\n{\n[Logging(LoggerOutputCase = LoggerOutputCase.CamelCase)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <p>Below are some output examples for different casing.</p> Camel CasePascal CaseSnake Case <pre><code>{\n\"level\": \"Information\",\n\"message\": \"Collecting payment\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"service\": \"payment\",\n\"coldStart\": true,\n\"functionName\": \"test\",\n\"functionMemorySize\": 128,\n\"functionArn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"functionRequestId\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\"\n}\n</code></pre> <pre><code>{\n\"Level\": \"Information\",\n\"Message\": \"Collecting payment\",\n\"Timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"Service\": \"payment\",\n\"ColdStart\": true,\n\"FunctionName\": \"test\",\n\"FunctionMemorySize\": 128,\n\"FunctionArn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"FunctionRequestId\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\"\n}\n</code></pre> <pre><code>{\n\"level\": \"Information\",\n\"message\": \"Collecting payment\",\n\"timestamp\": \"2021-12-13T20:32:22.5774262Z\",\n\"service\": \"payment\",\n\"cold_start\": true,\n\"function_name\": \"test\",\n\"function_memory_size\": 128,\n\"function_arn\": \"arn:aws:lambda:eu-west-1:12345678910:function:test\",\n\"function_request_id\": \"52fdfc07-2182-154f-163f-5f0f9a621d72\"\n}\n</code></pre>"},{"location":"core/metrics/","title":"Metrics","text":"<p>Metrics creates custom metrics asynchronously by logging metrics to standard output following Amazon CloudWatch Embedded Metric Format (EMF).</p> <p>These metrics can be visualized through Amazon CloudWatch Console.</p>"},{"location":"core/metrics/#key-features","title":"Key features","text":"<ul> <li>Aggregate up to 100 metrics using a single CloudWatch EMF object (large JSON blob)</li> <li>Validating your metrics against common metric definitions mistakes (for example, metric unit, values, max dimensions, max metrics)</li> <li>Metrics are created asynchronously by the CloudWatch service. You do not need any custom stacks, and there is no impact to Lambda function latency</li> <li>Context manager to create a one off metric with a different dimension</li> </ul> Metrics showcase - Metrics Explorer"},{"location":"core/metrics/#installation","title":"Installation","text":"<p>Powertools for AWS Lambda (.NET) are available as NuGet packages. You can install the packages from NuGet Gallery or from Visual Studio editor by searching <code>AWS.Lambda.Powertools*</code> to see various utilities available.</p> <ul> <li> <p>AWS.Lambda.Powertools.Metrics:</p> <p><code>dotnet nuget add AWS.Lambda.Powertools.Metrics</code></p> </li> </ul>"},{"location":"core/metrics/#terminologies","title":"Terminologies","text":"<p>If you're new to Amazon CloudWatch, there are two terminologies you must be aware of before using this utility:</p> <ul> <li>Namespace. It's the highest level container that will group multiple metrics from multiple services for a given application, for example <code>ServerlessEcommerce</code>.</li> <li>Dimensions. Metrics metadata in key-value format. They help you slice and dice metrics visualization, for example <code>ColdStart</code> metric by Payment <code>service</code>.</li> <li>Metric. It's the name of the metric, for example: SuccessfulBooking or UpdatedBooking.</li> <li>Unit. It's a value representing the unit of measure for the corresponding metric, for example: Count or Seconds.</li> <li>Resolution. It's a value representing the storage resolution for the corresponding metric. Metrics can be either Standard or High resolution. Read more here.</li> </ul> <p>Visit the AWS documentation for a complete explanation for Amazon CloudWatch concepts.</p> Metric terminology, visually explained"},{"location":"core/metrics/#getting-started","title":"Getting started","text":"<p><code>Metrics</code> is implemented as a Singleton to keep track of your aggregate metrics in memory and make them accessible anywhere in your code. To guarantee that metrics are flushed properly the <code>MetricsAttribute</code> must be added on the lambda handler.</p> <p>Metrics has two global settings that will be used across all metrics emitted. Use your application or main service as the metric namespace to easily group all metrics:</p> Setting Description Environment variable Constructor parameter Service Optionally, sets service metric dimension across all metrics e.g. <code>payment</code> <code>POWERTOOLS_SERVICE_NAME</code> <code>Service</code> Metric namespace Logical container where all metrics will be placed e.g. <code>MyCompanyEcommerce</code> <code>POWERTOOLS_METRICS_NAMESPACE</code> <code>Namespace</code> <p>Autocomplete Metric Units</p> <p>All parameters in <code>Metrics Attribute</code> are optional. Following rules apply:</p> <ul> <li>Namespace: <code>Empty</code> string by default. You can either specify it in code or environment variable. If not present before flushing metrics, a <code>SchemaValidationException</code> will be thrown.</li> <li>Service: <code>service_undefined</code> by default. You can either specify it in code or environment variable.</li> <li>CaptureColdStart: <code>false</code> by default. </li> <li>RaiseOnEmptyMetrics: <code>false</code> by default.</li> </ul>"},{"location":"core/metrics/#example-using-aws-serverless-application-model-aws-sam","title":"Example using AWS Serverless Application Model (AWS SAM)","text":"template.ymlFunction.cs <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function Properties:\n...\nEnvironment: Variables:\nPOWERTOOLS_SERVICE_NAME: ShoppingCartService\nPOWERTOOLS_METRICS_NAMESPACE: MyCompanyEcommerce\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n[Metrics(Namespace = \"MyCompanyEcommerce\", Service = \"ShoppingCartService\", CaptureColdStart = true, RaiseOnEmptyMetrics = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre>"},{"location":"core/metrics/#full-list-of-environment-variables","title":"Full list of environment variables","text":"Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging <code>\"service_undefined\"</code> POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics <code>None</code>"},{"location":"core/metrics/#creating-metrics","title":"Creating metrics","text":"<p>You can create metrics using <code>AddMetric</code>, and you can create dimensions for all your aggregate metrics using <code>AddDimension</code> method.</p> MetricsMetrics with custom dimensions <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count);\n}\n}\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.AddDimension(\"Environment\",\"Prod\");\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count);\n}\n}\n</code></pre> <p>Autocomplete Metric Units</p> <p><code>MetricUnit</code> enum facilitates finding a supported metric unit by CloudWatch.</p> <p>Metrics overflow</p> <p>CloudWatch EMF supports a max of 100 metrics per batch. Metrics utility will flush all metrics when adding the 100th metric. Subsequent metrics, e.g. 101th, will be aggregated into a new EMF object, for your convenience.</p> <p>Metric value must be a positive number</p> <p>Metric values must be a positive number otherwise an <code>ArgumentException</code> will be thrown.</p> <p>Do not create metrics or dimensions outside the handler</p> <p>Metrics or dimensions added in the global scope will only be added during cold start. Disregard if that's the intended behavior.</p>"},{"location":"core/metrics/#adding-high-resolution-metrics","title":"Adding high-resolution metrics","text":"<p>You can create high-resolution metrics passing <code>MetricResolution</code> as parameter to <code>AddMetric</code>.</p> <p>When is it useful?</p> <p>High-resolution metrics are data with a granularity of one second and are very useful in several situations such as telemetry, time series, real-time incident management, and others.</p> Metrics with high resolution <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Publish a metric with standard resolution i.e. StorageResolution = 60\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count, MetricResolution.Standard);\n// Publish a metric with high resolution i.e. StorageResolution = 1\nMetrics.AddMetric(\"FailedBooking\", 1, MetricUnit.Count, MetricResolution.High);\n// The last parameter (storage resolution) is optional\nMetrics.AddMetric(\"SuccessfulUpgrade\", 1, MetricUnit.Count);\n}\n}\n</code></pre> <p>Autocomplete Metric Resolutions</p> <p>Use the <code>MetricResolution</code> enum to easily find a supported metric resolution by CloudWatch.</p>"},{"location":"core/metrics/#adding-default-dimensions","title":"Adding default dimensions","text":"<p>You can use <code>SetDefaultDimensions</code> method to persist dimensions across Lambda invocations.</p> SetDefaultDimensions method <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\nprivate Dictionary&lt;string, string&gt; _defaultDimensions = new Dictionary&lt;string, string&gt;{\n{\"Environment\", \"Prod\"},\n{\"Another\", \"One\"}\n}; [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.SetDefaultDimensions(_defaultDimensions);\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count);\n}\n}\n</code></pre>"},{"location":"core/metrics/#flushing-metrics","title":"Flushing metrics","text":"<p>With <code>MetricsAttribute</code> all your metrics are validated, serialized and flushed to standard output when lambda handler completes execution or when you had the 100th metric to memory.</p> <p>During metrics validation, if no metrics are provided then a warning will be logged, but no exception will be raised.</p> Function.csExample CloudWatch Logs excerpt <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count);\n}\n}\n</code></pre> <pre><code>{\n\"BookingConfirmation\": 1.0,\n\"_aws\": {\n\"Timestamp\": 1592234975665,\n\"CloudWatchMetrics\": [\n{\n\"Namespace\": \"ExampleApplication\",\n\"Dimensions\": [\n[\n\"service\"\n]\n],\n\"Metrics\": [\n{\n\"Name\": \"BookingConfirmation\",\n\"Unit\": \"Count\"\n}\n]\n}\n]\n},\n\"service\": \"ExampleService\"\n}\n</code></pre> <p>Metric validation</p> <p>If metrics are provided, and any of the following criteria are not met, <code>SchemaValidationException</code> will be raised:</p> <ul> <li>Maximum of 9 dimensions</li> <li>Namespace is set</li> <li>Metric units must be supported by CloudWatch</li> </ul> <p>We do not emit 0 as a value for ColdStart metric for cost reasons. Let us know if you'd prefer a flag to override it</p>"},{"location":"core/metrics/#raising-schemavalidationexception-on-empty-metrics","title":"Raising SchemaValidationException on empty metrics","text":"<p>If you want to ensure that at least one metric is emitted, you can pass <code>RaiseOnEmptyMetrics</code> to the Metrics attribute:</p> Function.cs <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(RaiseOnEmptyMetrics = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n  {\n    ...\n</code></pre>"},{"location":"core/metrics/#capturing-cold-start-metric","title":"Capturing cold start metric","text":"<p>You can optionally capture cold start metrics by setting <code>CaptureColdStart</code> parameter to <code>true</code>.</p> Function.cs <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(CaptureColdStart = true)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n</code></pre> <p>If it's a cold start invocation, this feature will:</p> <ul> <li>Create a separate EMF blob solely containing a metric named <code>ColdStart</code></li> <li>Add <code>function_name</code> and <code>service</code> dimensions</li> </ul> <p>This has the advantage of keeping cold start metric separate from your application metrics, where you might have unrelated dimensions.</p>"},{"location":"core/metrics/#advanced","title":"Advanced","text":""},{"location":"core/metrics/#adding-metadata","title":"Adding metadata","text":"<p>You can add high-cardinality data as part of your Metrics log with <code>AddMetadata</code> method. This is useful when you want to search highly contextual information along with your metrics in your logs.</p> <p>Info</p> <p>This will not be available during metrics visualization - Use dimensions for this purpose</p> Function.csExample CloudWatch Logs excerpt <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = ExampleApplication, Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.AddMetric(\"SuccessfulBooking\", 1, MetricUnit.Count);\nMetrics.AddMetadata(\"BookingId\", \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\");\n...\n</code></pre> <pre><code>{\n\"SuccessfulBooking\": 1.0,\n\"_aws\": {\n\"Timestamp\": 1592234975665,\n\"CloudWatchMetrics\": [\n{\n\"Namespace\": \"ExampleApplication\",\n\"Dimensions\": [\n[\n\"service\"\n]\n],\n\"Metrics\": [\n{\n\"Name\": \"SuccessfulBooking\",\n\"Unit\": \"Count\"\n}\n]\n}\n]\n},\n\"Service\": \"Booking\",\n\"BookingId\": \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\"\n}\n</code></pre>"},{"location":"core/metrics/#single-metric-with-a-different-dimension","title":"Single metric with a different dimension","text":"<p>CloudWatch EMF uses the same dimensions across all your metrics. Use <code>PushSingleMetric</code> if you have a metric that should have different dimensions.</p> <p>Info</p> <p>Generally, this would be an edge case since you pay for unique metric. Keep the following formula in mind:</p> <p>unique metric = (metric_name + dimension_name + dimension_value)</p> Function.cs <pre><code>using AWS.Lambda.Powertools.Metrics;\n\npublic class Function {\n\n[Metrics(Namespace = ExampleApplication, Service = \"Booking\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nMetrics.PushSingleMetric(\nmetricName: \"ColdStart\",\nvalue: 1,\nunit: MetricUnit.Count,\nnameSpace: \"ExampleApplication\",\nservice: \"Booking\",\ndefaultDimensions: new Dictionary&lt;string, string&gt;\n{\n{\"FunctionContext\", \"$LATEST\"}\n});\n...\n</code></pre>"},{"location":"core/metrics/#testing-your-code","title":"Testing your code","text":""},{"location":"core/metrics/#environment-variables","title":"Environment variables","text":"Tip <p>Ignore this section, if:</p> <ul> <li>You are explicitly setting namespace/default dimension via <code>namespace</code> and <code>service</code> parameters</li> <li>You're not instantiating <code>Metrics</code> in the global namespace</li> </ul> <p>For example, <code>Metrics(namespace=\"ExampleApplication\", service=\"booking\")</code></p> <p>Make sure to set <code>POWERTOOLS_METRICS_NAMESPACE</code> and <code>POWERTOOLS_SERVICE_NAME</code> before running your tests to prevent failing on <code>SchemaValidation</code> exception. You can set it before you run tests by adding the environment variable.</p> Injecting Metric Namespace before running tests<pre><code>Environment.SetEnvironmentVariable(\"POWERTOOLS_METRICS_NAMESPACE\",\"AWSLambdaPowertools\");\n</code></pre>"},{"location":"core/tracing/","title":"Tracing","text":"<p>Powertools for AWS Lambda (.NET) tracing is an opinionated thin wrapper for AWS X-Ray .NET SDK a provides functionality to reduce the overhead of performing common tracing tasks.</p> <p></p>"},{"location":"core/tracing/#key-features","title":"Key Features","text":"<ul> <li>Helper methods to improve the developer experience for creating custom AWS X-Ray subsegments.</li> <li>Capture cold start as annotation.</li> <li>Capture function responses and full exceptions as metadata.</li> <li>Better experience when developing with multiple threads.</li> <li>Auto-patch supported modules by AWS X-Ray</li> </ul>"},{"location":"core/tracing/#installation","title":"Installation","text":"<p>Powertools for AWS Lambda (.NET) are available as NuGet packages. You can install the packages from NuGet Gallery or from Visual Studio editor by searching <code>AWS.Lambda.Powertools*</code> to see various utilities available.</p> <ul> <li> <p>AWS.Lambda.Powertools.Tracing:</p> <p><code>dotnet nuget add AWS.Lambda.Powertools.Tracing</code></p> </li> </ul>"},{"location":"core/tracing/#getting-started","title":"Getting Started","text":"<p>Before you use this utility, your AWS Lambda function must have permissions to send traces to AWS X-Ray.</p> <p>To enable active tracing on an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function resource, use the <code>Tracing</code> property. You can use the Globals section of the AWS SAM template to set this for all  </p>"},{"location":"core/tracing/#using-aws-serverless-application-model-aws-sam","title":"Using AWS Serverless Application Model (AWS SAM)","text":"template.yaml <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nRuntime: dotnet6.0\n\nTracing: Active\nEnvironment:\nVariables:\nPOWERTOOLS_SERVICE_NAME: example\n</code></pre> <p>The Powertools for AWS Lambda (.NET) service name is used as the X-Ray namespace. This can be set using the environment variable <code>POWERTOOLS_SERVICE_NAME</code></p>"},{"location":"core/tracing/#full-list-of-environment-variables","title":"Full list of environment variables","text":"Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging <code>\"service_undefined\"</code> POWERTOOLS_TRACE_DISABLED Disables tracing <code>false</code> POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. <code>true</code> POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. <code>true</code>"},{"location":"core/tracing/#lambda-handler","title":"Lambda handler","text":"<p>To enable Powertools for AWS Lambda (.NET) tracing to your function add the <code>[Tracing]</code> attribute to your <code>FunctionHandler</code> method or on any method will capture the method as a separate subsegment automatically. You can optionally choose to customize segment name that appears in traces.</p> Tracing attributeCustom Segment names <pre><code>public class Function\n{\n[Tracing]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nawait BusinessLogic1()\n.ConfigureAwait(false);\n\nawait BusinessLogic2()\n.ConfigureAwait(false);\n}\n\n[Tracing]\nprivate async Task BusinessLogic1()\n{\n\n}\n\n[Tracing]\nprivate async Task BusinessLogic2()\n{\n\n}\n}\n</code></pre> <pre><code>public class Function\n{\n[Tracing(SegmentName = \"YourCustomName\")]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <p>By default, this attribute will automatically record method responses and exceptions. You can change the default behavior by setting the environment variables <code>POWERTOOLS_TRACER_CAPTURE_RESPONSE</code> and <code>POWERTOOLS_TRACER_CAPTURE_ERROR</code> as needed. Optionally, you can override behavior by different supported <code>CaptureMode</code> to record response, exception or both.</p> <p>Returning sensitive information from your Lambda handler or functions, where <code>Tracing</code> is used?</p> <p>You can disable attribute from capturing their responses and exception as tracing metadata with <code>captureMode=DISABLED</code> or globally by setting environment variables <code>POWERTOOLS_TRACER_CAPTURE_RESPONSE</code> and <code>POWERTOOLS_TRACER_CAPTURE_ERROR</code> to <code>false</code></p> Disable on attributeDisable Globally <pre><code>public class Function\n{\n[Tracing(CaptureMode = TracingCaptureMode.Disabled)]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n...\n}\n}\n</code></pre> <pre><code>Resources:\nHelloWorldFunction:\nType: AWS::Serverless::Function\nProperties:\n...\nRuntime: dotnetcore3.1\n\nTracing: Active\nEnvironment:\nVariables:\nPOWERTOOLS_TRACER_CAPTURE_RESPONSE: false\nPOWERTOOLS_TRACER_CAPTURE_ERROR: false\n</code></pre>"},{"location":"core/tracing/#annotations-metadata","title":"Annotations &amp; Metadata","text":"<p>Annotations are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions.</p> <p>Metadata are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional context for an operation using any native object.</p> AnnotationsMetadata <p>You can add annotations using <code>AddAnnotation()</code> method from Tracing <pre><code>using AWS.Lambda.Powertools.Tracing;\n\npublic class Function\n{\n[Tracing]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nTracing.AddAnnotation(\"annotation\", \"value\");\n}\n}\n</code></pre></p> <p>You can add metadata using <code>AddMetadata()</code> method from Tracing <pre><code>using AWS.Lambda.Powertools.Tracing;\n\npublic class Function\n{\n[Tracing]\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nTracing.AddMetadata(\"content\", \"value\");\n}\n}\n</code></pre></p>"},{"location":"core/tracing/#utilities","title":"Utilities","text":"<p>Tracing modules comes with certain utility method when you don't want to use attribute for capturing a code block under a subsegment, or you are doing multithreaded programming. Refer examples below.</p> Functional ApiMulti Threaded Programming <pre><code>using AWS.Lambda.Powertools.Tracing;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\nTracing.WithSubsegment(\"loggingResponse\", (subsegment) =&gt; {\n// Some business logic\n});\nTracing.WithSubsegment(\"localNamespace\", \"loggingResponse\", (subsegment) =&gt; {\n// Some business logic\n});\n}\n}\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Tracing;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Extract existing trace data\nvar entity = Tracing.GetEntity();\n\nvar task = Task.Run(() =&gt;\n{\nTracing.WithSubsegment(\"InlineLog\", entity, (subsegment) =&gt;\n{\n// Business logic in separate task\n});\n});\n}\n}\n</code></pre>"},{"location":"core/tracing/#instrumenting-sdk-clients-and-http-calls","title":"Instrumenting SDK clients and HTTP calls","text":"<p>User should make sure to instrument the SDK clients explicitly based on the function dependency. Refer details on how to instrument SDK client with Xray and outgoing http calls.</p>"},{"location":"utilities/idempotency/","title":"Idempotency","text":"Warning <p>This utility is currently in developer preview and is intended strictly for feedback and testing purposes and not for production workloads. The version and all future versions tagged with the <code>-preview</code> suffix should be treated as not stable. Until this utility is General Availability we may introduce significant breaking changes and improvements in response to customers feedback.</p> <p>The idempotency utility provides a simple solution to convert your Lambda functions into idempotent operations which are safe to retry.</p>"},{"location":"utilities/idempotency/#terminology","title":"Terminology","text":"<p>The property of idempotency means that an operation does not cause additional side effects if it is called more than once with the same input parameters.</p> <p>Idempotent operations will return the same result when they are called multiple times with the same parameters. This makes idempotent operations safe to retry. Read more about idempotency.</p> <p>Idempotency key is a hash representation of either the entire event or a specific configured subset of the event, and invocation results are JSON serialized and stored in your persistence storage layer.</p>"},{"location":"utilities/idempotency/#key-features","title":"Key features","text":"<ul> <li>Prevent Lambda handler function from executing more than once on the same event payload during a time window</li> <li>Ensure Lambda handler returns the same result when called with the same payload</li> <li>Select a subset of the event as the idempotency key using JMESPath expressions</li> <li>Set a time window in which records with the same payload should be considered duplicates</li> </ul>"},{"location":"utilities/idempotency/#getting-started","title":"Getting started","text":""},{"location":"utilities/idempotency/#installation","title":"Installation","text":"<p>You should install with NuGet:</p> <pre><code>Install-Package AWS.Lambda.Powertools.Idempotency\n</code></pre> <p>Or via the .NET Core command line interface:</p> <pre><code>dotnet add package AWS.Lambda.Powertools.Idempotency\n</code></pre>"},{"location":"utilities/idempotency/#required-resources","title":"Required resources","text":"<p>Before getting started, you need to create a persistent storage layer where the idempotency utility can store its state - your Lambda functions will need read and write access to it.</p> <p>As of now, Amazon DynamoDB is the only supported persistent storage layer, so you'll need to create a table first.</p> <p>Default table configuration</p> <p>If you're not changing the default configuration for the DynamoDB persistence layer, this is the expected default configuration:</p> Configuration Value Notes Partition key <code>id</code> TTL attribute name <code>expiration</code> This can only be configured after your table is created if you're using AWS Console <p>Tip: You can share a single state table for all functions</p> <p>You can reuse the same DynamoDB table to store idempotency state. We add your function name in addition to the idempotency key as a hash key.</p> template.yml AWS Serverless Application Model (SAM) example<pre><code>Resources:\nIdempotencyTable:\nType: AWS::DynamoDB::Table\nProperties:\nAttributeDefinitions:\n- AttributeName: id\nAttributeType: S\nKeySchema:\n- AttributeName: id\nKeyType: HASH\nTimeToLiveSpecification:\nAttributeName: expiration\nEnabled: true\nBillingMode: PAY_PER_REQUEST\n\nIdempotencyFunction:\nType: AWS::Serverless::Function\nProperties:\nCodeUri: Function\nHandler: HelloWorld::HelloWorld.Function::FunctionHandler\nPolicies:\n- DynamoDBCrudPolicy:\nTableName: !Ref IdempotencyTable\nEnvironment:\nVariables:\nIDEMPOTENCY_TABLE: !Ref IdempotencyTable\n</code></pre> <p>Warning: Large responses with DynamoDB persistence layer</p> <p>When using this utility with DynamoDB, your function's responses must be smaller than 400KB. Larger items cannot be written to DynamoDB and will cause exceptions.</p> <p>Info: DynamoDB</p> <p>Each function invocation will generally make 2 requests to DynamoDB. If the result returned by your Lambda is less than 1kb, you can expect 2 WCUs per invocation. For retried invocations, you will see 1WCU and 1RCU. Review the DynamoDB pricing documentation to estimate the cost.</p>"},{"location":"utilities/idempotency/#idempotent-attribute","title":"Idempotent attribute","text":"<p>You can quickly start by configuring <code>Idempotency</code> and using it with the <code>Idempotent</code> attribute on your Lambda function.</p> <p>Important</p> <p>Initialization and configuration of the <code>Idempotency</code> must be performed outside the handler, preferably in the constructor.</p> <pre><code>public class Function\n{\npublic Function()\n{\nIdempotency.Configure(builder =&gt; builder.UseDynamoDb(\"idempotency_table\"));\n}\n\n[Idempotent]\npublic Task&lt;string&gt; FunctionHandler(string input, ILambdaContext context)\n{\nreturn Task.FromResult(input.ToUpper());\n}\n}\n</code></pre>"},{"location":"utilities/idempotency/#choosing-a-payload-subset-for-idempotency","title":"Choosing a payload subset for idempotency","text":"<p>Tip: Dealing with always changing payloads</p> <p>When dealing with an elaborate payload (API Gateway request for example), where parts of the payload always change, you should configure the <code>EventKeyJmesPath</code>.</p> <p>Use <code>IdempotencyConfig</code> to instruct the Idempotent annotation to only use a portion of your payload to verify whether a request is idempotent, and therefore it should not be retried.</p> <p>Payment scenario</p> <p>In this example, we have a Lambda handler that creates a payment for a user subscribing to a product. We want to ensure that we don't accidentally charge our customer by subscribing them more than once.</p> <p>Imagine the function executes successfully, but the client never receives the response due to a connection issue. It is safe to retry in this instance, as the idempotent decorator will return a previously saved response.</p> <p>Warning: Idempotency for JSON payloads</p> <p>The payload extracted by the <code>EventKeyJmesPath</code> is treated as a string by default, so will be sensitive to differences in whitespace even when the JSON payload itself is identical.</p> <p>To alter this behaviour, you can use the JMESPath built-in function <code>powertools_json()</code> to treat the payload as a JSON object rather than a string.</p> <pre><code>Idempotency.Configure(builder =&gt;\nbuilder\n.WithOptions(optionsBuilder =&gt;\noptionsBuilder.WithEventKeyJmesPath(\"powertools_json(Body).address\"))\n.UseDynamoDb(\"idempotency_table\"));\n</code></pre>"},{"location":"utilities/idempotency/#handling-exceptions","title":"Handling exceptions","text":"<p>If you are using the <code>Idempotent</code> attribute on your Lambda handler or any other method, any unhandled exceptions that are thrown during the code execution will cause the record in the persistence layer to be deleted. This means that new invocations will execute your code again despite having the same payload. If you don't want the record to be deleted, you need to catch exceptions within the idempotent function and return a successful response.</p> <p>Warning</p> <p>We will throw an <code>IdempotencyPersistenceLayerException</code> if any of the calls to the persistence layer fail unexpectedly.</p> <p>As this happens outside the scope of your decorated function, you are not able to catch it.</p>"},{"location":"utilities/idempotency/#persistence-stores","title":"Persistence stores","text":""},{"location":"utilities/idempotency/#dynamodbpersistencestore","title":"DynamoDBPersistenceStore","text":"<p>This persistence store is built-in, and you can either use an existing DynamoDB table or create a new one dedicated for idempotency state (recommended).</p> <p>Use the builder to customize the table structure: Customizing DynamoDBPersistenceStore to suit your table structure<pre><code>new DynamoDBPersistenceStoreBuilder()\n.WithTableName(\"TABLE_NAME\")\n.WithKeyAttr(\"idempotency_key\")\n.WithExpiryAttr(\"expires_at\")\n.WithStatusAttr(\"current_status\")\n.WithDataAttr(\"result_data\")\n.WithValidationAttr(\"validation_key\")\n.Build()\n</code></pre></p> <p>When using DynamoDB as a persistence layer, you can alter the attribute names by passing these parameters when initializing the persistence layer:</p> Parameter Required Default Description TableName Y Table name to store state KeyAttr <code>id</code> Partition key of the table. Hashed representation of the payload (unless SortKeyAttr is specified) ExpiryAttr <code>expiration</code> Unix timestamp of when record expires StatusAttr <code>status</code> Stores status of the Lambda execution during and after invocation DataAttr <code>data</code> Stores results of successfully idempotent methods ValidationAttr <code>validation</code> Hashed representation of the parts of the event used for validation SortKeyAttr Sort key of the table (if table is configured with a sort key). StaticPkValue <code>idempotency#{LAMBDA_FUNCTION_NAME}</code> Static value to use as the partition key. Only used when SortKeyAttr is set."},{"location":"utilities/idempotency/#advanced","title":"Advanced","text":""},{"location":"utilities/idempotency/#customizing-the-default-behavior","title":"Customizing the default behavior","text":"<p>Idempotency behavior can be further configured with <code>IdempotencyOptions</code> using a builder:</p> <pre><code>new IdempotencyOptionsBuilder()\n.WithEventKeyJmesPath(\"id\")\n.WithPayloadValidationJmesPath(\"paymentId\")\n.WithThrowOnNoIdempotencyKey(true)\n.WithExpiration(TimeSpan.FromMinutes(1))\n.WithUseLocalCache(true)\n.WithHashFunction(\"MD5\")\n.Build();\n</code></pre> <p>These are the available options for further configuration:</p> Parameter Default Description EventKeyJMESPath <code>\"\"</code> JMESPath expression to extract the idempotency key from the event record. PayloadValidationJMESPath <code>\"\"</code> JMESPath expression to validate whether certain parameters have changed in the event ThrowOnNoIdempotencyKey <code>False</code> Throw exception if no idempotency key was found in the request ExpirationInSeconds 3600 The number of seconds to wait before a record is expired UseLocalCache <code>false</code> Whether to locally cache idempotency results (LRU cache) HashFunction <code>MD5</code> Algorithm to use for calculating hashes, as supported by <code>System.Security.Cryptography.HashAlgorithm</code> (eg. SHA1, SHA-256, ...) <p>These features are detailed below.</p>"},{"location":"utilities/idempotency/#handling-concurrent-executions-with-the-same-payload","title":"Handling concurrent executions with the same payload","text":"<p>This utility will throw an <code>IdempotencyAlreadyInProgressException</code> if we receive multiple invocations with the same payload while the first invocation hasn't completed yet.</p> <p>Info</p> <p>If you receive <code>IdempotencyAlreadyInProgressException</code>, you can safely retry the operation.</p> <p>This is a locking mechanism for correctness. Since we don't know the result from the first invocation yet, we can't safely allow another concurrent execution.</p>"},{"location":"utilities/idempotency/#using-in-memory-cache","title":"Using in-memory cache","text":"<p>By default, in-memory local caching is disabled, to avoid using memory in an unpredictable way. </p> <p>Warning</p> <p>Be sure to configure the Lambda memory according to the number of records and the potential size of each record.</p> <p>You can enable it as seen before with: Enable local cache<pre><code>    new IdempotencyOptionsBuilder()\n.WithUseLocalCache(true)\n.Build()\n</code></pre> When enabled, we cache a maximum of 255 records in each Lambda execution environment</p> <p>Note: This in-memory cache is local to each Lambda execution environment</p> <p>This means it will be effective in cases where your function's concurrency is low in comparison to the number of \"retry\" invocations with the same payload, because cache might be empty.</p>"},{"location":"utilities/idempotency/#expiring-idempotency-records","title":"Expiring idempotency records","text":"<p>Note</p> <p>By default, we expire idempotency records after an hour (3600 seconds).</p> <p>In most cases, it is not desirable to store the idempotency records forever. Rather, you want to guarantee that the same payload won't be executed within a period of time.</p> <p>You can change this window with the <code>ExpirationInSeconds</code> parameter: Customizing expiration time<pre><code>new IdempotencyOptionsBuilder()\n.WithExpiration(TimeSpan.FromMinutes(5))\n.Build()\n</code></pre></p> <p>Records older than 5 minutes will be marked as expired, and the Lambda handler will be executed normally even if it is invoked with a matching payload.</p> <p>Note: DynamoDB time-to-live field</p> <p>This utility uses <code>expiration</code> as the TTL field in DynamoDB, as demonstrated in the SAM example earlier.</p>"},{"location":"utilities/idempotency/#payload-validation","title":"Payload validation","text":"<p>Question: What if your function is invoked with the same payload except some outer parameters have changed?</p> <p>Example: A payment transaction for a given productID was requested twice for the same customer, however the amount to be paid has changed in the second transaction.</p> <p>By default, we will return the same result as it returned before, however in this instance it may be misleading; we provide a fail fast payload validation to address this edge case.</p> <p>With <code>PayloadValidationJMESPath</code>, you can provide an additional JMESPath expression to specify which part of the event body should be validated against previous idempotent invocations</p> Function.csExample Event 1Example Event 2 <pre><code>Idempotency.Configure(builder =&gt;\nbuilder\n.WithOptions(optionsBuilder =&gt;\noptionsBuilder\n.WithEventKeyJmesPath(\"[userDetail, productId]\")\n.WithPayloadValidationJmesPath(\"amount\"))\n.UseDynamoDb(\"TABLE_NAME\"));\n</code></pre> <pre><code>{\n\"userDetail\": {\n\"username\": \"User1\",\n\"user_email\": \"user@example.com\"\n},\n\"productId\": 1500,\n\"charge_type\": \"subscription\",\n\"amount\": 500\n}\n</code></pre> <pre><code>{\n\"userDetail\": {\n\"username\": \"User1\",\n\"user_email\": \"user@example.com\"\n},\n\"productId\": 1500,\n\"charge_type\": \"subscription\",\n\"amount\": 1\n}\n</code></pre> <p>In this example, the <code>userDetail</code> and <code>productId</code> keys are used as the payload to generate the idempotency key, as per <code>EventKeyJMESPath</code> parameter.</p> <p>Note</p> <p>If we try to send the same request but with a different amount, we will raise <code>IdempotencyValidationException</code>.</p> <p>Without payload validation, we would have returned the same result as we did for the initial request. Since we're also returning an amount in the response, this could be quite confusing for the client.</p> <p>By using <code>withPayloadValidationJMESPath(\"amount\")</code>, we prevent this potentially confusing behavior and instead throw an Exception.</p>"},{"location":"utilities/idempotency/#making-idempotency-key-required","title":"Making idempotency key required","text":"<p>If you want to enforce that an idempotency key is required, you can set <code>ThrowOnNoIdempotencyKey</code> to <code>True</code>.</p> <p>This means that we will throw <code>IdempotencyKeyException</code> if the evaluation of <code>EventKeyJMESPath</code> is <code>null</code>.</p> Function.csSuccess EventFailure Event <pre><code>public App() {\nIdempotency.Configure(builder =&gt;\nbuilder\n.WithOptions(optionsBuilder =&gt;\noptionsBuilder\n// Requires \"user\".\"uid\" and \"orderId\" to be present\n.WithEventKeyJmesPath(\"[user.uid, orderId]\")\n.WithThrowOnNoIdempotencyKey(true))\n.UseDynamoDb(\"TABLE_NAME\"));\n}\n\n[Idempotent]\npublic Task&lt;OrderResult&gt; FunctionHandler(Order input, ILambdaContext context)\n{\n// ...\n}\n</code></pre> <pre><code>{\n\"user\": {\n\"uid\": \"BB0D045C-8878-40C8-889E-38B3CB0A61B1\",\n\"name\": \"Foo\"\n},\n\"orderId\": 10000\n}\n</code></pre> <p>Notice that <code>orderId</code> is now accidentally within <code>user</code> key</p> <pre><code>{\n\"user\": {\n\"uid\": \"DE0D000E-1234-10D1-991E-EAC1DD1D52C8\",\n\"name\": \"Joe Bloggs\",\n\"orderId\": 10000\n},\n}\n</code></pre>"},{"location":"utilities/idempotency/#customizing-dynamodb-configuration","title":"Customizing DynamoDB configuration","text":"<p>When creating the <code>DynamoDBPersistenceStore</code>, you can set a custom <code>AmazonDynamoDBClient</code> if you need to customize the configuration:</p> Custom AmazonDynamoDBClient <pre><code>public Function()\n{\nAmazonDynamoDBClient customClient = new AmazonDynamoDBClient(RegionEndpoint.APSouth1);\n\nIdempotency.Configure(builder =&gt; builder.UseDynamoDb(storeBuilder =&gt; storeBuilder.\nWithTableName(\"TABLE_NAME\")\n.WithDynamoDBClient(customClient)\n));\n}\n</code></pre>"},{"location":"utilities/idempotency/#using-a-dynamodb-table-with-a-composite-primary-key","title":"Using a DynamoDB table with a composite primary key","text":"<p>When using a composite primary key table (hash+range key), use <code>SortKeyAttr</code> parameter when initializing your persistence store.</p> <p>With this setting, we will save the idempotency key in the sort key instead of the primary key. By default, the primary key will now be set to <code>idempotency#{LAMBDA_FUNCTION_NAME}</code>.</p> <p>You can optionally set a static value for the partition key using the <code>StaticPkValue</code> parameter.</p> Reusing a DynamoDB table that uses a composite primary key<pre><code>Idempotency.Configure(builder =&gt; builder.UseDynamoDb(storeBuilder =&gt; storeBuilder.\nWithTableName(\"TABLE_NAME\")\n.WithSortKeyAttr(\"sort_key\")\n));\n</code></pre> <p>Data would then be stored in DynamoDB like this:</p> id sort_key expiration status data idempotency#MyLambdaFunction 1e956ef7da78d0cb890be999aecc0c9e 1636549553 COMPLETED {\"id\": 12391, \"message\": \"success\"} idempotency#MyLambdaFunction 2b2cdb5f86361e97b4383087c1ffdf27 1636549571 COMPLETED {\"id\": 527212, \"message\": \"success\"} idempotency#MyLambdaFunction f091d2527ad1c78f05d54cc3f363be80 1636549585 IN_PROGRESS"},{"location":"utilities/idempotency/#testing-your-code","title":"Testing your code","text":"<p>The idempotency utility provides several routes to test your code.</p>"},{"location":"utilities/idempotency/#disabling-the-idempotency-utility","title":"Disabling the idempotency utility","text":"<p>When testing your code, you may wish to disable the idempotency logic altogether and focus on testing your business logic. To do this, you can set the environment variable <code>POWERTOOLS_IDEMPOTENCY_DISABLED</code> to true. </p>"},{"location":"utilities/idempotency/#extra-resources","title":"Extra resources","text":"<p>If you're interested in a deep dive on how Amazon uses idempotency when building our APIs, check out this article.</p>"},{"location":"utilities/parameters/","title":"Parameters","text":"Warning <p>This utility is currently in developer preview and is intended strictly for feedback and testing purposes and not for production workloads. The version and all future versions tagged with the <code>-preview</code> suffix should be treated as not stable. Until this utility is General Availability we may introduce significant breaking changes and improvements in response to customers feedback.</p> <p>The Parameters utility provides high-level functionality to retrieve one or multiple parameter values from AWS Systems Manager Parameter Store, AWS Secrets Manager, or Amazon DynamoDB. We also provide extensibility to bring your own providers.</p>"},{"location":"utilities/parameters/#key-features","title":"Key features","text":"<ul> <li>Retrieve one or multiple parameters from the underlying provider</li> <li>Cache parameter values for a given amount of time (defaults to 5 seconds)</li> <li>Transform parameter values from JSON or base 64 encoded strings</li> <li>Bring your own parameter store provider</li> </ul>"},{"location":"utilities/parameters/#installation","title":"Installation","text":"<p>Powertools for AWS Lambda (.NET) are available as NuGet packages. You can install the packages from NuGet Gallery or from Visual Studio editor by searching <code>AWS.Lambda.Powertools*</code> to see various utilities available.</p> <ul> <li> <p>AWS.Lambda.Powertools.Parameters:</p> <p><code>dotnet nuget add AWS.Lambda.Powertools.Parameters</code></p> </li> </ul> <p>IAM Permissions</p> <p>This utility requires additional permissions to work as expected. See the table below:</p> Provider Function/Method IAM Permission SSM Parameter Store <code>SsmProvider.Get(string)</code> <code>SsmProvider.Get&lt;T&gt;(string)</code> <code>ssm:GetParameter</code> SSM Parameter Store <code>SsmProvider.GetMultiple(string)</code> <code>SsmProvider.GetMultiple&lt;T&gt;(string)</code> <code>ssm:GetParametersByPath</code> SSM Parameter Store If using <code>WithDecryption()</code> option You must add an additional permission <code>kms:Decrypt</code> Secrets Manager <code>SecretsProvider.Get(string)</code> <code>SecretsProvider.Get&lt;T&gt;(string)</code> <code>secretsmanager:GetSecretValue</code> DynamoDB <code>DynamoDBProvider.Get(string)</code> <code>DynamoDBProvider.Get&lt;T&gt;(string)</code> <code>dynamodb:GetItem</code> DynamoDB <code>DynamoDBProvider.GetMultiple(string)</code> <code>DynamoDBProvider.GetMultiple&lt;T&gt;(string)</code> <code>dynamodb:Query</code>"},{"location":"utilities/parameters/#ssm-parameter-store","title":"SSM Parameter Store","text":"<p>You can retrieve a single parameter using <code>SsmProvider.Get()</code> and pass the key of the parameter. For multiple parameters, you can use <code>SsmProvider.GetMultiple()</code> and pass the path to retrieve them all.</p> <p>Alternatively, you can retrieve the instance of provider and configure its underlying SDK client, in order to get data from other regions or use specific credentials.</p> SsmProviderSsmProvider with an explicit regionSsmProvider with a custom client <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider;\n// Retrieve a single parameter\nstring? value = await ssmProvider\n.GetAsync(\"/my/parameter\")\n.ConfigureAwait(false);\n\n// Retrieve multiple parameters from a path prefix\n// This returns a Dictionary with the parameter name as key\nIDictionary&lt;string, string?&gt; values = await ssmProvider\n.GetMultipleAsync(\"/my/path/prefix\")\n.ConfigureAwait(false);\n}\n}\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider\n.ConfigureClient(RegionEndpoint.EUCentral1);\n// Retrieve a single parameter\nstring? value = await ssmProvider\n.GetAsync(\"/my/parameter\")\n.ConfigureAwait(false);\n\n// Retrieve multiple parameters from a path prefix\n// This returns a Dictionary with the parameter name as key\nIDictionary&lt;string, string?&gt; values = await ssmProvider\n.GetMultipleAsync(\"/my/path/prefix\")\n.ConfigureAwait(false);\n}\n}\n</code></pre> <pre><code>using Amazon.SimpleSystemsManagement;\nusing AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Create a new instance of client\nIAmazonSimpleSystemsManagement client = new AmazonSimpleSystemsManagementClient();\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider\n.UseClient(client);\n// Retrieve a single parameter\nstring? value = await ssmProvider\n.GetAsync(\"/my/parameter\")\n.ConfigureAwait(false);\n\n// Retrieve multiple parameters from a path prefix\n// This returns a Dictionary with the parameter name as key\nIDictionary&lt;string, string?&gt; values = await ssmProvider\n.GetMultipleAsync(\"/my/path/prefix\")\n.ConfigureAwait(false);\n}\n}\n</code></pre>"},{"location":"utilities/parameters/#additional-arguments","title":"Additional arguments","text":"<p>The AWS Systems Manager Parameter Store provider supports two additional arguments for the <code>Get()</code> and <code>GetMultiple()</code> methods:</p> Option Default Description WithDecryption() <code>False</code> Will automatically decrypt the parameter. Recursive() <code>False</code> For <code>GetMultiple()</code> only, will fetch all parameter values recursively based on a path prefix. <p>You can create <code>SecureString</code> parameters, which are parameters that have a plaintext parameter name and an encrypted parameter value. If you don't use the <code>WithDecryption()</code> option, you will get an encrypted value. Read here about best practices using KMS to secure your parameters.</p> <p>Example:</p> Function.cs <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider;\n\n// Retrieve a single parameter\nstring? value = await ssmProvider\n.WithDecryption()\n.GetAsync(\"/my/parameter\")\n.ConfigureAwait(false);\n// Retrieve multiple parameters from a path prefix\n// This returns a Dictionary with the parameter name as key\nIDictionary&lt;string, string?&gt; values = await ssmProvider\n.Recursive()\n.GetMultipleAsync(\"/my/path/prefix\")\n.ConfigureAwait(false);\n}\n}\n</code></pre>"},{"location":"utilities/parameters/#secrets-manager","title":"Secrets Manager","text":"<p>For secrets stored in Secrets Manager, use <code>SecretsProvider</code>.</p> <p>Alternatively, you can retrieve the instance of provider and configure its underlying SDK client, in order to get data from other regions or use specific credentials.</p> SecretsProviderSecretsProvider with an explicit regionSecretsProvider with a custom client <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SecretsManager;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get Secrets Provider instance\nISecretsProvider secretsProvider = ParametersManager.SecretsProvider;\n\n// Retrieve a single secret\nstring? value = await secretsProvider\n.GetAsync(\"/my/secret\")\n.ConfigureAwait(false);\n}\n}\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SecretsManager;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get Secrets Provider instance\nISecretsProvider secretsProvider = ParametersManager.SecretsProvider\n.ConfigureClient(RegionEndpoint.EUCentral1);\n// Retrieve a single secret\nstring? value = await secretsProvider\n.GetAsync(\"/my/secret\")\n.ConfigureAwait(false);\n}\n}\n</code></pre> <pre><code>using Amazon.SecretsManager;\nusing AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SecretsManager;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Create a new instance of client\nIAmazonSecretsManager client = new AmazonSecretsManagerClient(); // Get Secrets Provider instance\nISecretsProvider secretsProvider = ParametersManager.SecretsProvider\n.UseClient(client);\n// Retrieve a single secret\nstring? value = await secretsProvider\n.GetAsync(\"/my/secret\")\n.ConfigureAwait(false);\n}\n}\n</code></pre>"},{"location":"utilities/parameters/#dynamodb-provider","title":"DynamoDB Provider","text":"<p>For parameters stored in a DynamoDB table, use <code>DynamoDBProvider</code>.</p> <p>DynamoDB table structure for single parameters</p> <p>For single parameters, you must use <code>id</code> as the partition key for that table.</p> Example <p>DynamoDB table with <code>id</code> partition key and <code>value</code> as attribute</p> id value my-parameter my-value <p>With this table, <code>DynamoDBProvider.Get(\"my-param\")</code> will return <code>my-value</code>.</p> DynamoDBProvider <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.DynamoDB;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get DynamoDB Provider instance\nIDynamoDBProvider dynamoDbProvider = ParametersManager.DynamoDBProvider\n.UseTable(\"my-table\");\n// Retrieve a single parameter\nstring? value = await dynamoDbProvider\n.GetAsync(\"my-param\")\n.ConfigureAwait(false);\n}\n}\n</code></pre> <p>DynamoDB table structure for multiple values parameters</p> <p>You can retrieve multiple parameters sharing the same <code>id</code> by having a sort key named <code>sk</code>.</p> Example <p>DynamoDB table with <code>id</code> primary key, <code>sk</code> as sort key<code>and</code>value` as attribute</p> id sk value my-hash-key param-a my-value-a my-hash-key param-b my-value-b my-hash-key param-c my-value-c <p>With this table, <code>DynamoDBProvider.GetMultiple(\"my-hash-key\")</code> will return a dictionary response in the shape of <code>sk:value</code>.</p> DynamoDBProviderparameters dictionary response <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.DynamoDB;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get DynamoDB Provider instance\nIDynamoDBProvider dynamoDbProvider = ParametersManager.DynamoDBProvider\n.UseTable(\"my-table\");\n// Retrieve a single parameter\nIDictionary&lt;string, string?&gt; value = await dynamoDbProvider\n.GetMultipleAsync(\"my-hash-key\")\n.ConfigureAwait(false);\n}\n}\n</code></pre> <p>```json {     \"param-a\": \"my-value-a\",     \"param-b\": \"my-value-b\",     \"param-c\": \"my-value-c\" }</p> <p>Customizing DynamoDBProvider</p> <p>DynamoDB provider can be customized at initialization to match your table structure:</p> Parameter Mandatory Default Description table_name Yes (N/A) Name of the DynamoDB table containing the parameter values. key_attr No <code>id</code> Hash key for the DynamoDB table. sort_attr No <code>sk</code> Range key for the DynamoDB table. You don't need to set this if you don't use the <code>GetMultiple()</code> method. value_attr No <code>value</code> Name of the attribute containing the parameter value. DynamoDBProvider <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.DynamoDB;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get DynamoDB Provider instance\nIDynamoDBProvider dynamoDbProvider = ParametersManager.DynamoDBProvider\n.UseTable\n(\ntableName: \"TableName\",    // DynamoDB table name, Required.\nprimaryKeyAttribute: \"id\", // Partition Key attribute name, optional, default is 'id'\nsortKeyAttribute: \"sk\",    // Sort Key attribute name, optional, default is 'sk'\nvalueAttribute: \"value\"    // Value attribute name, optional, default is 'value'\n);\n}\n}\n</code></pre>"},{"location":"utilities/parameters/#advanced-configuration","title":"Advanced configuration","text":""},{"location":"utilities/parameters/#caching","title":"Caching","text":"<p>By default, all parameters and their corresponding values are cached for 5 seconds.</p> <p>You can customize this default value using <code>DefaultMaxAge</code>. You can also customize this value for each parameter using  <code>WithMaxAge</code>.</p> <p>If you'd like to always ensure you fetch the latest parameter from the store regardless if already available in cache, use <code>ForceFetch</code>.</p> Provider with default Max ageProvider with age for each parameterForce to fetch the latest parameter <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider\n.DefaultMaxAge(TimeSpan.FromSeconds(10));\n// Retrieve a single parameter\nstring? value = await ssmProvider\n.GetAsync(\"/my/parameter\")\n.ConfigureAwait(false);\n}\n}\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider;\n\n// Retrieve a single parameter\nstring? value = await ssmProvider\n.WithMaxAge(TimeSpan.FromSeconds(10))\n.GetAsync(\"/my/parameter\")\n.ConfigureAwait(false);\n}\n}\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider;\n\n// Retrieve a single parameter\nstring? value = await ssmProvider\n.ForceFetch()\n.GetAsync(\"/my/parameter\")\n.ConfigureAwait(false);\n}\n}\n</code></pre>"},{"location":"utilities/parameters/#transform-values","title":"Transform values","text":"<p>Parameter values can be transformed using <code>WithTransformation()</code>. Base64 and JSON transformations are provided. For more complex transformation, you need to specify how to deserialize by writing your own transfomer.</p> JSON TransformationBase64 Transformation <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider;\n\n// Retrieve a single parameter\nvar value = await ssmProvider\n.WithTransformation(Transformation.Json)\n.GetAsync&lt;MyObj&gt;(\"/my/parameter/json\")\n.ConfigureAwait(false);\n}\n}\n</code></pre> <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider;\n\n// Retrieve a single parameter\nvar value = await ssmProvider\n.WithTransformation(Transformation.Base64)\n.GetAsync(\"/my/parameter/b64\")\n.ConfigureAwait(false);\n}\n}\n</code></pre>"},{"location":"utilities/parameters/#partial-transform-failures-with-getmultiple","title":"Partial transform failures with <code>GetMultiple()</code>","text":"<p>If you use <code>Transformation</code> with <code>GetMultiple()</code>, you can have a single malformed parameter value. To prevent failing the entire request, the method will return a <code>Null</code> value for the parameters that failed to transform.</p> <p>You can override this by using <code>RaiseTransformationError()</code>. If you do so, a single transform error will raise a <code>TransformationException</code> exception.</p> Function.cs <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider\n.RaiseTransformationError();\n// Retrieve a single parameter\nvar value = await ssmProvider\n.WithTransformation(Transformation.Json)\n.GetAsync&lt;MyObj&gt;(\"/my/parameter/json\")\n.ConfigureAwait(false);\n}\n}\n</code></pre>"},{"location":"utilities/parameters/#auto-transform-values-on-suffix","title":"Auto-transform values on suffix","text":"<p>If you use <code>Transformation</code> with <code>GetMultiple()</code>, you might want to retrieve and transform parameters encoded in different formats.</p> <p>You can do this with a single request by using <code>Transformation.Auto</code>. This will instruct any Parameter to to infer its type based on the suffix and transform it accordingly.</p> Function.cs <pre><code>using AWS.Lambda.Powertools.Parameters;\nusing AWS.Lambda.Powertools.Parameters.SimpleSystemsManagement;\n\npublic class Function\n{\npublic async Task&lt;APIGatewayProxyResponse&gt; FunctionHandler\n(APIGatewayProxyRequest apigProxyEvent, ILambdaContext context)\n{\n// Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider;\n\n// Retrieve multiple parameters from a path prefix\n// This returns a Dictionary with the parameter name as key\nIDictionary&lt;string, object?&gt; values = await ssmProvider\n.WithTransformation(Transformation.Auto)\n.GetMultipleAsync(\"/param\")\n.ConfigureAwait(false);\n}\n}\n</code></pre> <p>For example, if you have two parameters with the following suffixes <code>.json</code> and <code>.binary</code>:</p> Parameter name Parameter value /param/a.json [some encoded value] /param/a.binary [some encoded value] <p>The return of <code>GetMultiple()</code> with <code>Transformation.Auto</code> will be a dictionary like:</p> <pre><code>{\n\"a.json\": [some value],\n\"b.binary\": [some value]\n}\n</code></pre>"},{"location":"utilities/parameters/#write-your-own-transformer","title":"Write your own Transformer","text":"<p>You can write your own transformer, by implementing the <code>ITransformer</code> interface and the <code>Transform&lt;T&gt;(string)</code> method. For example, if you wish to deserialize XML into an object.</p> XmlTransformer.csUsing XmlTransformerAdding XmlTransformer as transformer <pre><code>public class XmlTransformer : ITransformer\n{\npublic T? Transform&lt;T&gt;(string value)\n{\nif (string.IsNullOrEmpty(value))\nreturn default;\n\nvar serializer = new XmlSerializer(typeof(T));\nusing var reader = new StringReader(value);\nreturn (T?)serializer.Deserialize(reader);\n}\n}\n</code></pre> <pre><code>    var value = await ssmProvider\n.WithTransformation(new XmlTransformer())\n.GetAsync&lt;MyObj&gt;(\"/my/parameter/xml\")\n.ConfigureAwait(false);\n</code></pre> <pre><code>    // Get SSM Provider instance\nISsmProvider ssmProvider = ParametersManager.SsmProvider\n.AddTransformer(\"XML\", new XmlTransformer());\n// Retrieve a single parameter\nvar value = await ssmProvider\n.WithTransformation(\"XML\")\n.GetAsync&lt;MyObj&gt;(\"/my/parameter/xml\")\n.ConfigureAwait(false);\n</code></pre>"},{"location":"utilities/parameters/#fluent-api","title":"Fluent API","text":"<p>To simplify the use of the library, you can chain all method calls before a get.</p> Fluent API call <pre><code>    ssmProvider\n.DefaultMaxAge(TimeSpan.FromSeconds(10))  // will set 10 seconds as the default cache TTL\n.WithMaxAge(TimeSpan.FromMinutes(1))      // will set the cache TTL for this value at 1 minute\n.WithTransformation(Transformation.Json)  // Will use JSON transfomer to deserializes JSON to an object\n.WithDecryption()                         // enable decryption of the parameter value\n.Get&lt;MyObj&gt;(\"/my/param\");                 // finally get the value\n</code></pre>"},{"location":"utilities/parameters/#create-your-own-provider","title":"Create your own provider","text":"<p>You can create your own custom parameter provider by inheriting the <code>BaseProvider</code> class and implementing the <code>String getValue(String key)</code> method to retrieve data from your underlying store. All transformation and caching logic is handled by the get() methods in the base class.</p> Example implementation using S3 as a custom parameterUsing custom parameter store <pre><code>public class S3Provider : ParameterProvider\n{\n\nprivate string _bucket;\nprivate readonly IAmazonS3 _client;\n\npublic S3Provider()\n{\n_client = new AmazonS3Client();\n}\n\npublic S3Provider(IAmazonS3 client)\n{\n_client = client;\n}\n\npublic S3Provider WithBucket(string bucket)\n{\n_bucket = bucket;\nreturn this;\n}\n\nprotected override async Task&lt;string?&gt; GetAsync(string key, ParameterProviderConfiguration? config)\n{\nif (string.IsNullOrEmpty(key))\nthrow new ArgumentNullException(nameof(key));\n\nif (string.IsNullOrEmpty(_bucket))\nthrow new ArgumentException(\"A bucket must be specified, using withBucket() method\");\n\nvar request = new GetObjectRequest\n{\nKey = key,\nBucketName = _bucket\n};\n\nusing var response = await _client.GetObjectAsync(request);\nawait using var responseStream = response.ResponseStream;\nusing var reader = new StreamReader(responseStream);\nreturn await reader.ReadToEndAsync();\n}\n\nprotected override async Task&lt;IDictionary&lt;string, string?&gt;&gt; GetMultipleAsync(string path, ParameterProviderConfiguration? config)\n{\nif (string.IsNullOrEmpty(path))\nthrow new ArgumentNullException(nameof(path));\n\nif (string.IsNullOrEmpty(_bucket))\nthrow new ArgumentException(\"A bucket must be specified, using withBucket() method\");\n\nvar request = new ListObjectsV2Request\n{\nPrefix = path,\nBucketName = _bucket\n};\nvar response = await _client.ListObjectsV2Async(request);\n\nvar result = new Dictionary&lt;string, string?&gt;();\nforeach (var s3Object in response.S3Objects)\n{\nvar value = await GetAsync(s3Object.Key);\nresult.Add(s3Object.Key, value);\n}\n\nreturn result;\n}\n}\n</code></pre> <pre><code>    var provider = new S3Provider();\n\nvar value = await provider\n.WithBucket(\"myBucket\")\n.GetAsync(\"myKey\")\n.ConfigureAwait(false);\n</code></pre>"}]}