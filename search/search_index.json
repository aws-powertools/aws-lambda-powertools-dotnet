{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AWS Lambda Powertools for .NET \u00b6 AWS Lambda Powertools for .NET is a suite of utilities for AWS Lambda functions to ease adopting best practices such as tracing, structured logging, custom metrics, and more. Please note, Powertools for .NET is optimised for .NET 6 only . The GitHub repository for this project can be found here . Do not use this library in production AWS Lambda Powertools for .NET is currently released as a alpha developer preview and is intended strictly for feedback purposes only. This version is not stable, and significant breaking changes might incur as part of the upcoming production-ready release. Your support is much appreciated. If you encounter any problems, please raise an issue . Do not use this library for production workloads. Available Powertools libraries \u00b6 Utility Description Tracing Decorators and utilities to trace Lambda function handlers, and both synchronous and asynchronous functions Logger Structured logging made easier, and decorator to enrich structured logging with key Lambda context details Metrics Custom AWS metrics created asynchronously via CloudWatch Embedded Metric Format (EMF) Looking for a quick read through how the core features are used? Check out the Simplifying serverless best practices with Lambda Powertools blog post with a practical example. Install \u00b6 The AWS Lambda Powertools for .NET utilities (.NET 6) are available as Nuget packages. You can install the packages from Nuget gallery or from Visual Studio editor. Search AWS.Lambda.Powertools* to see various utilities available.Powertools is available on NuGet. AWS.Lambda.Powertools.Tracing : dotnet nuget add AWS.Lambda.Powertools.Tracing AWS.Lambda.Powertools.Logging : dotnet nuget add AWS.Lambda.Powertools.Logging AWS.Lambda.Powertools.Metrics : dotnet nuget add AWS.Lambda.Powertools.Metrics SAM CLI custom template \u00b6 We have provided you with a custom template for the Serverless Application Model (AWS SAM) command-line interface (CLI). This generates a starter project that allows you to interactively choose the Powertools features that enables you to include in your project. 1 sam init --location https://github.com/aws-samples/cookiecutter-aws-sam-dotnet To use the SAM CLI, you need the following tools. SAM CLI - Install the SAM CLI .NET 6.0 (LTS) - Install .NET 6.0 Docker - Install Docker community edition Examples \u00b6 We have provided a few examples that should you how to use the each of the core Powertools features. Tracer example Logger example Metrics example Other members of the AWS Lambda Powertools family \u00b6 Not using .NET? No problem we have you covered. Here are the other members of the AWS Lambda Powertools family: AWS Lambda Powertools for Python AWS Lambda Powertools for Java AWS Lambda Powertools for TypeScript Connect \u00b6 AWS Developers Slack : #lambda-powertools - Invite, if you don't have an account Email : aws-lambda-powertools-feedback@amazon.com Credits \u00b6 Credits for the Lambda Powertools idea go to DAZN and their DAZN Lambda Powertools .","title":"Homepage"},{"location":"#aws-lambda-powertools-for-net","text":"AWS Lambda Powertools for .NET is a suite of utilities for AWS Lambda functions to ease adopting best practices such as tracing, structured logging, custom metrics, and more. Please note, Powertools for .NET is optimised for .NET 6 only . The GitHub repository for this project can be found here . Do not use this library in production AWS Lambda Powertools for .NET is currently released as a alpha developer preview and is intended strictly for feedback purposes only. This version is not stable, and significant breaking changes might incur as part of the upcoming production-ready release. Your support is much appreciated. If you encounter any problems, please raise an issue . Do not use this library for production workloads.","title":"AWS Lambda Powertools for .NET"},{"location":"#available-powertools-libraries","text":"Utility Description Tracing Decorators and utilities to trace Lambda function handlers, and both synchronous and asynchronous functions Logger Structured logging made easier, and decorator to enrich structured logging with key Lambda context details Metrics Custom AWS metrics created asynchronously via CloudWatch Embedded Metric Format (EMF) Looking for a quick read through how the core features are used? Check out the Simplifying serverless best practices with Lambda Powertools blog post with a practical example.","title":"Available Powertools libraries"},{"location":"#install","text":"The AWS Lambda Powertools for .NET utilities (.NET 6) are available as Nuget packages. You can install the packages from Nuget gallery or from Visual Studio editor. Search AWS.Lambda.Powertools* to see various utilities available.Powertools is available on NuGet. AWS.Lambda.Powertools.Tracing : dotnet nuget add AWS.Lambda.Powertools.Tracing AWS.Lambda.Powertools.Logging : dotnet nuget add AWS.Lambda.Powertools.Logging AWS.Lambda.Powertools.Metrics : dotnet nuget add AWS.Lambda.Powertools.Metrics","title":"Install"},{"location":"#sam-cli-custom-template","text":"We have provided you with a custom template for the Serverless Application Model (AWS SAM) command-line interface (CLI). This generates a starter project that allows you to interactively choose the Powertools features that enables you to include in your project. 1 sam init --location https://github.com/aws-samples/cookiecutter-aws-sam-dotnet To use the SAM CLI, you need the following tools. SAM CLI - Install the SAM CLI .NET 6.0 (LTS) - Install .NET 6.0 Docker - Install Docker community edition","title":"SAM CLI custom template"},{"location":"#examples","text":"We have provided a few examples that should you how to use the each of the core Powertools features. Tracer example Logger example Metrics example","title":"Examples"},{"location":"#other-members-of-the-aws-lambda-powertools-family","text":"Not using .NET? No problem we have you covered. Here are the other members of the AWS Lambda Powertools family: AWS Lambda Powertools for Python AWS Lambda Powertools for Java AWS Lambda Powertools for TypeScript","title":"Other members of the AWS Lambda Powertools family"},{"location":"#connect","text":"AWS Developers Slack : #lambda-powertools - Invite, if you don't have an account Email : aws-lambda-powertools-feedback@amazon.com","title":"Connect"},{"location":"#credits","text":"Credits for the Lambda Powertools idea go to DAZN and their DAZN Lambda Powertools .","title":"Credits"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. This project follows Keep a Changelog format for changes and adheres to Semantic Versioning . [Unreleased] \u00b6 [0.1.0] - 2021-11-15 \u00b6 Added \u00b6 Public beta release","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. This project follows Keep a Changelog format for changes and adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"changelog/#010-2021-11-15","text":"","title":"[0.1.0] - 2021-11-15"},{"location":"changelog/#added","text":"Public beta release","title":"Added"},{"location":"references/","text":"Environment variables \u00b6 Info Explicit parameters take precedence over environment variables. Environment variable Description Utility Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging All \"service_undefined\" POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics Metrics None POWERTOOLS_TRACE_DISABLED Disables tracing Tracing false POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. Tracing true POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. Tracing true POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event Logging false POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling Logging 0 POWERTOOLS_LOG_DEDUPLICATION_DISABLED Disables log deduplication filter protection to use Pytest Live Log feature Logging false SAM template snippets \u00b6 TODO....","title":"References"},{"location":"references/#environment-variables","text":"Info Explicit parameters take precedence over environment variables. Environment variable Description Utility Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging All \"service_undefined\" POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics Metrics None POWERTOOLS_TRACE_DISABLED Disables tracing Tracing false POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. Tracing true POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. Tracing true POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event Logging false POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling Logging 0 POWERTOOLS_LOG_DEDUPLICATION_DISABLED Disables log deduplication filter protection to use Pytest Live Log feature Logging false","title":"Environment variables"},{"location":"references/#sam-template-snippets","text":"TODO....","title":"SAM template snippets"},{"location":"tenets/","text":"Core utilities such as Tracing, Logging, Metrics, and Event Handler will be available across all Lambda Powertools runtimes. Additional utilities are subjective to each language ecosystem and customer demand. AWS Lambda only . We optimise for AWS Lambda function environments and supported runtimes only. Utilities might work with web frameworks and non-Lambda environments, though they are not officially supported. Eases the adoption of best practices . The main priority of the utilities is to facilitate best practices adoption, as defined in the AWS Well-Architected Serverless Lens; all other functionality is optional. Keep it lean . Additional dependencies are carefully considered for security and ease of maintenance, and prevent negatively impacting startup time. We strive for backwards compatibility . New features and changes should keep backwards compatibility. If a breaking change cannot be avoided, the deprecation and migration process should be clearly defined. We work backwards from the community . We aim to strike a balance of what would work best for 80% of customers. Emerging practices are considered and discussed via Requests for Comment (RFCs) Idiomatic . Utilities follow programming language idioms and language-specific best practices.","title":"Our tenets"},{"location":"core/logging/","text":"Logging provides an opinionated logger with output structured as JSON. Key features \u00b6 Capture key fields from Lambda context, cold start and structures logging output as JSON Log Lambda event when instructed (disabled by default) Log sampling enables DEBUG log level for a percentage of requests (disabled by default) Append additional keys to structured log at any point in time Getting started \u00b6 Logging requires two settings: Setting Description Environment variable Attribute parameter Logging level Sets how verbose Logger should be (Information, by default) LOG_LEVEL LogLevel Service Sets Service key that will be present across all log statements POWERTOOLS_SERVICE_NAME Service Example using AWS Serverless Application Model (AWS SAM) \u00b6 You can also override log level by setting POWERTOOLS_LOG_LEVEL env var. Here is an example using AWS Serverless Application Model (AWS SAM) template.yaml 1 2 3 4 5 6 7 8 9 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Environment : Variables : POWERTOOLS_LOG_LEVEL : Debug POWERTOOLS_SERVICE_NAME : example You can also explicitly set a service name via POWERTOOLS_SERVICE_NAME env var. This sets service key that will be present across all log statements. Standard structured keys \u00b6 Your logs will always include the following keys to your structured logging: Key Type Example Description Timestamp string \"2020-05-24 18:17:33,774\" Timestamp of actual log statement Level string \"Information\" Logging level Name string \"Powertools Logger\" Logger name ColdStart bool true ColdStart value. Service string \"payment\" Service name defined. \"service_undefined\" will be used if unknown SamplingRate int 0.1 Debug logging sampling rate in percentage e.g. 10% in this case Message string \"Collecting payment\" Log statement value. Unserializable JSON values will be casted to string FunctionName string \"example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" FunctionVersion string \"12\" FunctionMemorySize string \"128\" FunctionArn string \"arn:aws:lambda:eu-west-1:012345678910:function:example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" XRayTraceId string \"1-5759e988-bd862e3fe1be46a994272793\" X-Ray Trace ID when Lambda function has enabled Tracing FunctionRequestId string \"899856cb-83d1-40d7-8611-9e78f15f32f4\" AWS Request ID from lambda context Logging incoming event \u00b6 When debugging in non-production environments, you can instruct Logger to log the incoming event with LogEvent parameter or via POWERTOOLS_LOGGER_LOG_EVENT environment variable. Warning Log event is disabled by default to prevent sensitive info being logged. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Setting a Correlation ID \u00b6 You can set a Correlation ID using CorrelationIdPath parameter by passing a JSON Pointer expression . Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(CorrelationIdPath = \"/headers/my_request_id_header\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Example Event 1 2 3 4 5 { \"headers\" : { \"my_request_id_header\" : \"correlation_id_value\" } } Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"cold_start\" : true , \"xray_trace_id\" : \"1-61b7add4-66532bb81441e1b060389429\" , \"function_name\" : \"test\" , \"function_version\" : \"$LATEST\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"level\" : \"Information\" , \"service\" : \"lambda-example\" , \"name\" : \"AWS.Lambda.Powertools.Logging.Logger\" , \"message\" : \"Collecting payment\" , \"sampling_rate\" : 0.7 , \"correlation_id\" : \"correlation_id_value\" , } We provide built-in JSON Pointer expression for known event sources, where either a request ID or X-Ray Trace ID are present. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(CorrelationIdPath = CorrelationIdPaths.API_GATEWAY_REST)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Example Event 1 2 3 4 5 { \"RequestContext\" : { \"RequestId\" : \"correlation_id_value\" } } Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"cold_start\" : true , \"xray_trace_id\" : \"1-61b7add4-66532bb81441e1b060389429\" , \"function_name\" : \"test\" , \"function_version\" : \"$LATEST\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"level\" : \"Information\" , \"service\" : \"lambda-example\" , \"name\" : \"AWS.Lambda.Powertools.Logging.Logger\" , \"message\" : \"Collecting payment\" , \"sampling_rate\" : 0.7 , \"correlation_id\" : \"correlation_id_value\" , } Appending additional keys \u00b6 Custom keys are persisted across warm invocations Always set additional keys as part of your handler to ensure they have the latest value, or explicitly clear them with ClearState=true . You can append your own keys to your existing logs via AppendKey . Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... Logger . AppendKey ( \"test\" , \"willBeLogged\" ); ... var customKeys = new Dictionary < string , string > { { \"test1\" , \"value1\" }, { \"test2\" , \"value2\" } }; Logger . AppendKeys ( customKeys ); ... } } Removing additional keys \u00b6 You can remove any additional key from entry using Logger.RemoveKeys() . Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... Logger . AppendKey ( \"test\" , \"willBeLogged\" ); ... var customKeys = new Dictionary < string , string > { { \"test1\" , \"value1\" }, { \"test2\" , \"value2\" } }; Logger . AppendKeys ( customKeys ); ... Logger . RemoveKeys ( \"test\" ); Logger . RemoveKeys ( \"test1\" , \"test2\" ); ... } } Extra Keys \u00b6 Extra keys argument is available for all log levels' methods, as implemented in the standard logging library - e.g. Logger.Information, Logger.Warning. It accepts any dictionary, and all keyword arguments will be added as part of the root structure of the logs for that log statement. Info Any keyword argument added using extra keys will not be persisted for subsequent messages. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... var extraKeys = new Dictionary < string , string > { { \"extraKey1\" , \"value1\" } }; Logger . LogInformation ( extraKeys , \"Collecting payment\" ); ... } } Clearing all state \u00b6 Logger is commonly initialized in the global scope. Due to Lambda Execution Context reuse , this means that custom keys can be persisted across invocations. If you want all custom keys to be deleted, you can use ClearState=true attribute on [Logging] attribute. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Handler for requests to Lambda function. */ public class Function { [Logging(ClearState = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... if ( apigProxyEvent . Headers . ContainsKey ( \"SomeSpecialHeader\" )) { Logger . AppendKey ( \"SpecialKey\" , \"value\" ); } Logger . LogInformation ( \"Collecting payment\" ); ... } } #1 Request 1 2 3 4 5 6 7 8 9 10 11 12 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"special_key\" : \"value\" } #2 Request 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" } Sampling debug logs \u00b6 You can dynamically set a percentage of your logs to DEBUG level via env var POWERTOOLS_LOGGER_SAMPLE_RATE or via SamplingRate parameter on attribute. Info Configuration on environment variable is given precedence over sampling rate configuration on attribute, provided it's in valid value range. Sampling via attribute parameter 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(SamplingRate = 0.5)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Sampling via environment variable 1 2 3 4 5 6 7 8 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Environment : Variables : POWERTOOLS_LOGGER_SAMPLE_RATE : 0.5 Configure Log Output Casing \u00b6 By definition AWS Lambda Powertools for .NET outputs logging keys using snake case (e.g. \"function_memory_size\": 128 ). This allows developers using different AWS Lambda Powertools runtimes, to search logs across services written in languages such as Python or TypeScript. If you want to override the default behaviour you can either set the desired casing through attributes, as described in the example below, or by setting the POWERTOOLS_LOGGER_CASE environment variable on your AWS Lambda function. Allowed values are: CamelCase , PascalCase and SnakeCase . Output casing via attribute parameter 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LoggerOutputCase = LoggerOutputCase.CamelCase)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Below are some output examples for different casing. Camel Case 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"coldStart\" : true , \"functionName\" : \"test\" , \"functionMemorySize\" : 128 , \"functionArn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"functionRequestId\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" } Pascal Case 1 2 3 4 5 6 7 8 9 10 11 { \"Level\" : \"Information\" , \"Message\" : \"Collecting payment\" , \"Timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"Service\" : \"payment\" , \"ColdStart\" : true , \"FunctionName\" : \"test\" , \"FunctionMemorySize\" : 128 , \"FunctionArn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"FunctionRequestId\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" } Snake Case 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" }","title":"Logging"},{"location":"core/logging/#key-features","text":"Capture key fields from Lambda context, cold start and structures logging output as JSON Log Lambda event when instructed (disabled by default) Log sampling enables DEBUG log level for a percentage of requests (disabled by default) Append additional keys to structured log at any point in time","title":"Key features"},{"location":"core/logging/#getting-started","text":"Logging requires two settings: Setting Description Environment variable Attribute parameter Logging level Sets how verbose Logger should be (Information, by default) LOG_LEVEL LogLevel Service Sets Service key that will be present across all log statements POWERTOOLS_SERVICE_NAME Service","title":"Getting started"},{"location":"core/logging/#example-using-aws-serverless-application-model-aws-sam","text":"You can also override log level by setting POWERTOOLS_LOG_LEVEL env var. Here is an example using AWS Serverless Application Model (AWS SAM) template.yaml 1 2 3 4 5 6 7 8 9 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Environment : Variables : POWERTOOLS_LOG_LEVEL : Debug POWERTOOLS_SERVICE_NAME : example You can also explicitly set a service name via POWERTOOLS_SERVICE_NAME env var. This sets service key that will be present across all log statements.","title":"Example using AWS Serverless Application Model (AWS SAM)"},{"location":"core/logging/#standard-structured-keys","text":"Your logs will always include the following keys to your structured logging: Key Type Example Description Timestamp string \"2020-05-24 18:17:33,774\" Timestamp of actual log statement Level string \"Information\" Logging level Name string \"Powertools Logger\" Logger name ColdStart bool true ColdStart value. Service string \"payment\" Service name defined. \"service_undefined\" will be used if unknown SamplingRate int 0.1 Debug logging sampling rate in percentage e.g. 10% in this case Message string \"Collecting payment\" Log statement value. Unserializable JSON values will be casted to string FunctionName string \"example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" FunctionVersion string \"12\" FunctionMemorySize string \"128\" FunctionArn string \"arn:aws:lambda:eu-west-1:012345678910:function:example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" XRayTraceId string \"1-5759e988-bd862e3fe1be46a994272793\" X-Ray Trace ID when Lambda function has enabled Tracing FunctionRequestId string \"899856cb-83d1-40d7-8611-9e78f15f32f4\" AWS Request ID from lambda context","title":"Standard structured keys"},{"location":"core/logging/#logging-incoming-event","text":"When debugging in non-production environments, you can instruct Logger to log the incoming event with LogEvent parameter or via POWERTOOLS_LOGGER_LOG_EVENT environment variable. Warning Log event is disabled by default to prevent sensitive info being logged. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } }","title":"Logging incoming event"},{"location":"core/logging/#setting-a-correlation-id","text":"You can set a Correlation ID using CorrelationIdPath parameter by passing a JSON Pointer expression . Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(CorrelationIdPath = \"/headers/my_request_id_header\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Example Event 1 2 3 4 5 { \"headers\" : { \"my_request_id_header\" : \"correlation_id_value\" } } Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"cold_start\" : true , \"xray_trace_id\" : \"1-61b7add4-66532bb81441e1b060389429\" , \"function_name\" : \"test\" , \"function_version\" : \"$LATEST\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"level\" : \"Information\" , \"service\" : \"lambda-example\" , \"name\" : \"AWS.Lambda.Powertools.Logging.Logger\" , \"message\" : \"Collecting payment\" , \"sampling_rate\" : 0.7 , \"correlation_id\" : \"correlation_id_value\" , } We provide built-in JSON Pointer expression for known event sources, where either a request ID or X-Ray Trace ID are present. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(CorrelationIdPath = CorrelationIdPaths.API_GATEWAY_REST)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Example Event 1 2 3 4 5 { \"RequestContext\" : { \"RequestId\" : \"correlation_id_value\" } } Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"cold_start\" : true , \"xray_trace_id\" : \"1-61b7add4-66532bb81441e1b060389429\" , \"function_name\" : \"test\" , \"function_version\" : \"$LATEST\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"level\" : \"Information\" , \"service\" : \"lambda-example\" , \"name\" : \"AWS.Lambda.Powertools.Logging.Logger\" , \"message\" : \"Collecting payment\" , \"sampling_rate\" : 0.7 , \"correlation_id\" : \"correlation_id_value\" , }","title":"Setting a Correlation ID"},{"location":"core/logging/#appending-additional-keys","text":"Custom keys are persisted across warm invocations Always set additional keys as part of your handler to ensure they have the latest value, or explicitly clear them with ClearState=true . You can append your own keys to your existing logs via AppendKey . Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... Logger . AppendKey ( \"test\" , \"willBeLogged\" ); ... var customKeys = new Dictionary < string , string > { { \"test1\" , \"value1\" }, { \"test2\" , \"value2\" } }; Logger . AppendKeys ( customKeys ); ... } }","title":"Appending additional keys"},{"location":"core/logging/#removing-additional-keys","text":"You can remove any additional key from entry using Logger.RemoveKeys() . Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... Logger . AppendKey ( \"test\" , \"willBeLogged\" ); ... var customKeys = new Dictionary < string , string > { { \"test1\" , \"value1\" }, { \"test2\" , \"value2\" } }; Logger . AppendKeys ( customKeys ); ... Logger . RemoveKeys ( \"test\" ); Logger . RemoveKeys ( \"test1\" , \"test2\" ); ... } }","title":"Removing additional keys"},{"location":"core/logging/#extra-keys","text":"Extra keys argument is available for all log levels' methods, as implemented in the standard logging library - e.g. Logger.Information, Logger.Warning. It accepts any dictionary, and all keyword arguments will be added as part of the root structure of the logs for that log statement. Info Any keyword argument added using extra keys will not be persisted for subsequent messages. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... var extraKeys = new Dictionary < string , string > { { \"extraKey1\" , \"value1\" } }; Logger . LogInformation ( extraKeys , \"Collecting payment\" ); ... } }","title":"Extra Keys"},{"location":"core/logging/#clearing-all-state","text":"Logger is commonly initialized in the global scope. Due to Lambda Execution Context reuse , this means that custom keys can be persisted across invocations. If you want all custom keys to be deleted, you can use ClearState=true attribute on [Logging] attribute. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Handler for requests to Lambda function. */ public class Function { [Logging(ClearState = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... if ( apigProxyEvent . Headers . ContainsKey ( \"SomeSpecialHeader\" )) { Logger . AppendKey ( \"SpecialKey\" , \"value\" ); } Logger . LogInformation ( \"Collecting payment\" ); ... } } #1 Request 1 2 3 4 5 6 7 8 9 10 11 12 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"special_key\" : \"value\" } #2 Request 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" }","title":"Clearing all state"},{"location":"core/logging/#sampling-debug-logs","text":"You can dynamically set a percentage of your logs to DEBUG level via env var POWERTOOLS_LOGGER_SAMPLE_RATE or via SamplingRate parameter on attribute. Info Configuration on environment variable is given precedence over sampling rate configuration on attribute, provided it's in valid value range. Sampling via attribute parameter 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(SamplingRate = 0.5)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Sampling via environment variable 1 2 3 4 5 6 7 8 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Environment : Variables : POWERTOOLS_LOGGER_SAMPLE_RATE : 0.5","title":"Sampling debug logs"},{"location":"core/logging/#configure-log-output-casing","text":"By definition AWS Lambda Powertools for .NET outputs logging keys using snake case (e.g. \"function_memory_size\": 128 ). This allows developers using different AWS Lambda Powertools runtimes, to search logs across services written in languages such as Python or TypeScript. If you want to override the default behaviour you can either set the desired casing through attributes, as described in the example below, or by setting the POWERTOOLS_LOGGER_CASE environment variable on your AWS Lambda function. Allowed values are: CamelCase , PascalCase and SnakeCase . Output casing via attribute parameter 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LoggerOutputCase = LoggerOutputCase.CamelCase)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Below are some output examples for different casing. Camel Case 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"coldStart\" : true , \"functionName\" : \"test\" , \"functionMemorySize\" : 128 , \"functionArn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"functionRequestId\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" } Pascal Case 1 2 3 4 5 6 7 8 9 10 11 { \"Level\" : \"Information\" , \"Message\" : \"Collecting payment\" , \"Timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"Service\" : \"payment\" , \"ColdStart\" : true , \"FunctionName\" : \"test\" , \"FunctionMemorySize\" : 128 , \"FunctionArn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"FunctionRequestId\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" } Snake Case 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" }","title":"Configure Log Output Casing"},{"location":"core/metrics/","text":"Metrics creates custom metrics asynchronously by logging metrics to standard output following Amazon CloudWatch Embedded Metric Format (EMF) . These metrics can be visualized through Amazon CloudWatch Console . Key features \u00b6 Aggregate up to 100 metrics using a single CloudWatch EMF object (large JSON blob) Validate against common metric definitions mistakes (metric unit, values, max dimensions, max metrics, etc) Metrics are created asynchronously by CloudWatch service, no custom stacks needed Context manager to create a one off metric with a different dimension Terminologies \u00b6 If you're new to Amazon CloudWatch, there are two terminologies you must be aware of before using this utility: Namespace . It's the highest level container that will group multiple metrics from multiple services for a given application, for example ServerlessEcommerce . Dimensions . Metrics metadata in key-value format. They help you slice and dice metrics visualization, for example ColdStart metric by Payment service . Metric terminology, visually explained Getting started \u00b6 Metric has two global settings that will be used across all metrics emitted: Setting Description Environment variable Constructor parameter Metric namespace Logical container where all metrics will be placed e.g. ServerlessAirline POWERTOOLS_METRICS_NAMESPACE Namespace Service Optionally, sets service metric dimension across all metrics e.g. payment POWERTOOLS_SERVICE_NAME Service Use your application or main service as the metric namespace to easily group all metrics Example using AWS Serverless Application Model (AWS SAM) template.yml 1 2 3 4 5 6 7 8 9 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Environment : Variables : POWERTOOLS_SERVICE_NAME : Payment POWERTOOLS_METRICS_NAMESPACE : ServerlessAirline Function.cs 1 2 3 4 5 6 7 8 9 using AWS.Lambda.Powertools.Metrics ; public class Function { Metrics ( Namespace = \"ServerlessAirline\" , Service = \"Orders\" , CaptureColdStart = true , RaiseOnEmptyMetrics = true )] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Metrics Attribute placement Metrics is implemented as a Singleton to keep track of your aggregate metrics in memory and make them accessible anywhere in your code. To guarantee that metrics are flushed properly the MetricsAttribute must be added on the lambda handler. Autocomplete Metric Units All parameters in Metrics Attribute are optional. Following rules apply: Namespace: Empty string by default. You can either specify it in code or environment variable. If not present before flushing metrics, a SchemaValidationException will be thrown. Service: service_undefined by default. You can either specify it in code or environment variable. CaptureColdStart: false by default. RaiseOnEmptyMetrics: false by default. Creating metrics \u00b6 You can create metrics using AddMetric , and you can create dimensions for all your aggregate metrics using AddDimension method. Metrics 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } Metrics with custom dimensions 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddDimension ( \"Environment\" , \"Prod\" ); Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } Autocomplete Metric Units MetricUnit enum facilitates finding a supported metric unit by CloudWatch. Metrics overflow CloudWatch EMF supports a max of 100 metrics per batch. Metrics utility will flush all metrics when adding the 100th metric. Subsequent metrics, e.g. 101th, will be aggregated into a new EMF object, for your convenience. Metric value must be a positive number Metric values must be a positive number otherwise an ArgumentException will be thrown. Do not create metrics or dimensions outside the handler Metrics or dimensions added in the global scope will only be added during cold start. Disregard if that's the intended behaviour. Adding default dimensions \u00b6 You can use SetDefaultDimensions method to persist dimensions across Lambda invocations. SetDefaultDimensions method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using AWS.Lambda.Powertools.Metrics ; public class Function { private Dictionary < string , string > _defaultDimensions = new Dictionary < string , string >{ { \"Environment\" , \"Prod\" }, { \"Another\" , \"One\" } }; [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . SetDefaultDimensions ( _defaultDimensions ); Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } Flushing metrics \u00b6 With MetricsAttribute all your metrics are validated, serialized and flushed to standard output when lambda handler completes execution or when you had the 100th metric to memory. During metrics validation, if no metrics are provided then a warning will be logged, but no exception will be raised. Function.cs 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"BookingConfirmation\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"ExampleApplication\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"BookingConfirmation\" , \"Unit\" : \"Count\" } ] } ] }, \"service\" : \"ExampleService\" } Metric validation If metrics are provided, and any of the following criteria are not met, SchemaValidationException will be raised: Maximum of 9 dimensions Namespace is set Metric units must be supported by CloudWatch We do not emit 0 as a value for ColdStart metric for cost reasons. Let us know if you'd prefer a flag to override it Raising SchemaValidationException on empty metrics \u00b6 If you want to ensure that at least one metric is emitted, you can pass RaiseOnEmptyMetrics to the Metrics attribute: Function.cs 1 2 3 4 5 6 7 8 using AWS . Lambda . Powertools . Metrics ; public class Function { [ Metrics ( RaiseOnEmptyMetrics = true )] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... Capturing cold start metric \u00b6 You can optionally capture cold start metrics by setting CaptureColdStart parameter to true . Function.cs 1 2 3 4 5 6 7 8 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(CaptureColdStart = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... If it's a cold start invocation, this feature will: Create a separate EMF blob solely containing a metric named ColdStart Add function_name and service dimensions This has the advantage of keeping cold start metric separate from your application metrics, where you might have unrelated dimensions. Advanced \u00b6 Adding metadata \u00b6 You can add high-cardinality data as part of your Metrics log with AddMetadata method. This is useful when you want to search highly contextual information along with your metrics in your logs. Info This will not be available during metrics visualization - Use dimensions for this purpose Function.cs 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = ExampleApplication, Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); Metrics . AddMetadata ( \"BookingId\" , \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\" ); ... Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"SuccessfulBooking\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"ExampleApplication\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"SuccessfulBooking\" , \"Unit\" : \"Count\" } ] } ] }, \"Service\" : \"Booking\" , \"BookingId\" : \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\" } Single metric with a different dimension \u00b6 CloudWatch EMF uses the same dimensions across all your metrics. Use PushSingleMetric if you have a metric that should have different dimensions. Info Generally, this would be an edge case since you pay for unique metric . Keep the following formula in mind: unique metric = (metric_name + dimension_name + dimension_value) Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = ExampleApplication, Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . PushSingleMetric ( metricName : \"ColdStart\" , value : 1 , unit : MetricUnit . COUNT , nameSpace : \"ExampleApplication\" , service : \"Booking\" , defaultDimensions : new Dictionary < string , string > { { \"FunctionContext\" , \"$LATEST\" } }); ...","title":"Metrics"},{"location":"core/metrics/#key-features","text":"Aggregate up to 100 metrics using a single CloudWatch EMF object (large JSON blob) Validate against common metric definitions mistakes (metric unit, values, max dimensions, max metrics, etc) Metrics are created asynchronously by CloudWatch service, no custom stacks needed Context manager to create a one off metric with a different dimension","title":"Key features"},{"location":"core/metrics/#terminologies","text":"If you're new to Amazon CloudWatch, there are two terminologies you must be aware of before using this utility: Namespace . It's the highest level container that will group multiple metrics from multiple services for a given application, for example ServerlessEcommerce . Dimensions . Metrics metadata in key-value format. They help you slice and dice metrics visualization, for example ColdStart metric by Payment service . Metric terminology, visually explained","title":"Terminologies"},{"location":"core/metrics/#getting-started","text":"Metric has two global settings that will be used across all metrics emitted: Setting Description Environment variable Constructor parameter Metric namespace Logical container where all metrics will be placed e.g. ServerlessAirline POWERTOOLS_METRICS_NAMESPACE Namespace Service Optionally, sets service metric dimension across all metrics e.g. payment POWERTOOLS_SERVICE_NAME Service Use your application or main service as the metric namespace to easily group all metrics Example using AWS Serverless Application Model (AWS SAM) template.yml 1 2 3 4 5 6 7 8 9 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Environment : Variables : POWERTOOLS_SERVICE_NAME : Payment POWERTOOLS_METRICS_NAMESPACE : ServerlessAirline Function.cs 1 2 3 4 5 6 7 8 9 using AWS.Lambda.Powertools.Metrics ; public class Function { Metrics ( Namespace = \"ServerlessAirline\" , Service = \"Orders\" , CaptureColdStart = true , RaiseOnEmptyMetrics = true )] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Metrics Attribute placement Metrics is implemented as a Singleton to keep track of your aggregate metrics in memory and make them accessible anywhere in your code. To guarantee that metrics are flushed properly the MetricsAttribute must be added on the lambda handler. Autocomplete Metric Units All parameters in Metrics Attribute are optional. Following rules apply: Namespace: Empty string by default. You can either specify it in code or environment variable. If not present before flushing metrics, a SchemaValidationException will be thrown. Service: service_undefined by default. You can either specify it in code or environment variable. CaptureColdStart: false by default. RaiseOnEmptyMetrics: false by default.","title":"Getting started"},{"location":"core/metrics/#creating-metrics","text":"You can create metrics using AddMetric , and you can create dimensions for all your aggregate metrics using AddDimension method. Metrics 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } Metrics with custom dimensions 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddDimension ( \"Environment\" , \"Prod\" ); Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } Autocomplete Metric Units MetricUnit enum facilitates finding a supported metric unit by CloudWatch. Metrics overflow CloudWatch EMF supports a max of 100 metrics per batch. Metrics utility will flush all metrics when adding the 100th metric. Subsequent metrics, e.g. 101th, will be aggregated into a new EMF object, for your convenience. Metric value must be a positive number Metric values must be a positive number otherwise an ArgumentException will be thrown. Do not create metrics or dimensions outside the handler Metrics or dimensions added in the global scope will only be added during cold start. Disregard if that's the intended behaviour.","title":"Creating metrics"},{"location":"core/metrics/#adding-default-dimensions","text":"You can use SetDefaultDimensions method to persist dimensions across Lambda invocations. SetDefaultDimensions method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using AWS.Lambda.Powertools.Metrics ; public class Function { private Dictionary < string , string > _defaultDimensions = new Dictionary < string , string >{ { \"Environment\" , \"Prod\" }, { \"Another\" , \"One\" } }; [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . SetDefaultDimensions ( _defaultDimensions ); Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } }","title":"Adding default dimensions"},{"location":"core/metrics/#flushing-metrics","text":"With MetricsAttribute all your metrics are validated, serialized and flushed to standard output when lambda handler completes execution or when you had the 100th metric to memory. During metrics validation, if no metrics are provided then a warning will be logged, but no exception will be raised. Function.cs 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"BookingConfirmation\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"ExampleApplication\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"BookingConfirmation\" , \"Unit\" : \"Count\" } ] } ] }, \"service\" : \"ExampleService\" } Metric validation If metrics are provided, and any of the following criteria are not met, SchemaValidationException will be raised: Maximum of 9 dimensions Namespace is set Metric units must be supported by CloudWatch We do not emit 0 as a value for ColdStart metric for cost reasons. Let us know if you'd prefer a flag to override it","title":"Flushing metrics"},{"location":"core/metrics/#raising-schemavalidationexception-on-empty-metrics","text":"If you want to ensure that at least one metric is emitted, you can pass RaiseOnEmptyMetrics to the Metrics attribute: Function.cs 1 2 3 4 5 6 7 8 using AWS . Lambda . Powertools . Metrics ; public class Function { [ Metrics ( RaiseOnEmptyMetrics = true )] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ...","title":"Raising SchemaValidationException on empty metrics"},{"location":"core/metrics/#capturing-cold-start-metric","text":"You can optionally capture cold start metrics by setting CaptureColdStart parameter to true . Function.cs 1 2 3 4 5 6 7 8 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(CaptureColdStart = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... If it's a cold start invocation, this feature will: Create a separate EMF blob solely containing a metric named ColdStart Add function_name and service dimensions This has the advantage of keeping cold start metric separate from your application metrics, where you might have unrelated dimensions.","title":"Capturing cold start metric"},{"location":"core/metrics/#advanced","text":"","title":"Advanced"},{"location":"core/metrics/#adding-metadata","text":"You can add high-cardinality data as part of your Metrics log with AddMetadata method. This is useful when you want to search highly contextual information along with your metrics in your logs. Info This will not be available during metrics visualization - Use dimensions for this purpose Function.cs 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = ExampleApplication, Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); Metrics . AddMetadata ( \"BookingId\" , \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\" ); ... Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"SuccessfulBooking\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"ExampleApplication\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"SuccessfulBooking\" , \"Unit\" : \"Count\" } ] } ] }, \"Service\" : \"Booking\" , \"BookingId\" : \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\" }","title":"Adding metadata"},{"location":"core/metrics/#single-metric-with-a-different-dimension","text":"CloudWatch EMF uses the same dimensions across all your metrics. Use PushSingleMetric if you have a metric that should have different dimensions. Info Generally, this would be an edge case since you pay for unique metric . Keep the following formula in mind: unique metric = (metric_name + dimension_name + dimension_value) Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = ExampleApplication, Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . PushSingleMetric ( metricName : \"ColdStart\" , value : 1 , unit : MetricUnit . COUNT , nameSpace : \"ExampleApplication\" , service : \"Booking\" , defaultDimensions : new Dictionary < string , string > { { \"FunctionContext\" , \"$LATEST\" } }); ...","title":"Single metric with a different dimension"},{"location":"core/tracing/","text":"Powertools tracing is an opinionated thin wrapper for AWS X-Ray .NET SDK a provides functionality to reduce the overhead of performing common tracing tasks. Key Features \u00b6 Helper methods to improve the developer experience for creating custom AWS X-Ray subsegments . Capture cold start as annotation. Capture function responses and full exceptions as metadata. Better experience when developing with multiple threads. Auto-patch supported modules by AWS X-Ray Initialization \u00b6 Before you use this utility, your AWS Lambda function must have permissions to send traces to AWS X-Ray. To enable active tracing on an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function resource, use the Tracing property. You can use the Globals section of the AWS SAM template to set this for all Using AWS Serverless Application Model (AWS SAM) \u00b6 template.yaml 1 2 3 4 5 6 7 8 9 10 11 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Runtime : dotnet6.0 Tracing : Active Environment : Variables : POWERTOOLS_SERVICE_NAME : example The Powertools service name is used as the X-Ray namespace. This can be set using the environment variable POWERTOOLS_SERVICE_NAME Lambda handler \u00b6 To enable Powertools tracing to your function add the [Tracing] attribute to your FunctionHandler method or on any method will capture the method as a separate subsegment automatically. You can optionally choose to customize segment name that appears in traces. Tracing attribute 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { await BusinessLogic1 () . ConfigureAwait ( false ); await BusinessLogic2 () . ConfigureAwait ( false ); } [Tracing] private async Task BusinessLogic1 () { } [Tracing] private async Task BusinessLogic2 () { } } Custom Segment names 1 2 3 4 5 6 7 8 9 public class Function { [Tracing(SegmentName = \"YourCustomName\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } By default, this attribute will automatically record method responses and exceptions. You can change the default behavior by setting the environment variables POWERTOOLS_TRACER_CAPTURE_RESPONSE and POWERTOOLS_TRACER_CAPTURE_ERROR as needed. Optionally, you can override behavior by different supported CaptureMode to record response, exception or both. Returning sensitive information from your Lambda handler or functions, where Tracing is used? You can disable attribute from capturing their responses and exception as tracing metadata with captureMode=DISABLED or globally by setting environment variables POWERTOOLS_TRACER_CAPTURE_RESPONSE and POWERTOOLS_TRACER_CAPTURE_ERROR to false Disable on attribute 1 2 3 4 5 6 7 8 9 public class Function { [Tracing(CaptureMode = TracingCaptureMode.Disabled)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Disable Globally 1 2 3 4 5 6 7 8 9 10 11 12 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Runtime : dotnetcore3.1 Tracing : Active Environment : Variables : POWERTOOLS_TRACER_CAPTURE_RESPONSE : false POWERTOOLS_TRACER_CAPTURE_ERROR : false Annotations & Metadata \u00b6 Annotations are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions. Metadata are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional context for an operation using any native object. Annotations You can add annotations using AddAnnotation() method from Tracing 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Tracing ; public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . AddAnnotation ( \"annotation\" , \"value\" ); } } Metadata You can add metadata using AddMetadata() method from Tracing 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Tracing ; public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . AddMetadata ( \"content\" , \"value\" ); } } Utilities \u00b6 Tracing modules comes with certain utility method when you don't want to use attribute for capturing a code block under a subsegment, or you are doing multithreaded programming. Refer examples below. Functional Api 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 using AWS.Lambda.Powertools.Tracing ; public class Function { public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . WithSubsegment ( \"loggingResponse\" , ( subsegment ) => { // Some business logic }); Tracing . WithSubsegment ( \"localNamespace\" , \"loggingResponse\" , ( subsegment ) => { // Some business logic }); } } Multi Threaded Programming 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using AWS.Lambda.Powertools.Tracing ; public class Function { public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { // Extract existing trace data var entity = Tracing . GetEntity (); var task = Task . Run (() => { Tracing . WithSubsegment ( \"InlineLog\" , entity , ( subsegment ) => { // Business logic in separate task }); }); } } Instrumenting SDK clients and HTTP calls \u00b6 User should make sure to instrument the SDK clients explicitly based on the function dependency. Refer details on how to instrument SDK client with Xray and outgoing http calls .","title":"Tracing"},{"location":"core/tracing/#key-features","text":"Helper methods to improve the developer experience for creating custom AWS X-Ray subsegments . Capture cold start as annotation. Capture function responses and full exceptions as metadata. Better experience when developing with multiple threads. Auto-patch supported modules by AWS X-Ray","title":"Key Features"},{"location":"core/tracing/#initialization","text":"Before you use this utility, your AWS Lambda function must have permissions to send traces to AWS X-Ray. To enable active tracing on an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function resource, use the Tracing property. You can use the Globals section of the AWS SAM template to set this for all","title":"Initialization"},{"location":"core/tracing/#using-aws-serverless-application-model-aws-sam","text":"template.yaml 1 2 3 4 5 6 7 8 9 10 11 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Runtime : dotnet6.0 Tracing : Active Environment : Variables : POWERTOOLS_SERVICE_NAME : example The Powertools service name is used as the X-Ray namespace. This can be set using the environment variable POWERTOOLS_SERVICE_NAME","title":"Using AWS Serverless Application Model (AWS SAM)"},{"location":"core/tracing/#lambda-handler","text":"To enable Powertools tracing to your function add the [Tracing] attribute to your FunctionHandler method or on any method will capture the method as a separate subsegment automatically. You can optionally choose to customize segment name that appears in traces. Tracing attribute 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { await BusinessLogic1 () . ConfigureAwait ( false ); await BusinessLogic2 () . ConfigureAwait ( false ); } [Tracing] private async Task BusinessLogic1 () { } [Tracing] private async Task BusinessLogic2 () { } } Custom Segment names 1 2 3 4 5 6 7 8 9 public class Function { [Tracing(SegmentName = \"YourCustomName\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } By default, this attribute will automatically record method responses and exceptions. You can change the default behavior by setting the environment variables POWERTOOLS_TRACER_CAPTURE_RESPONSE and POWERTOOLS_TRACER_CAPTURE_ERROR as needed. Optionally, you can override behavior by different supported CaptureMode to record response, exception or both. Returning sensitive information from your Lambda handler or functions, where Tracing is used? You can disable attribute from capturing their responses and exception as tracing metadata with captureMode=DISABLED or globally by setting environment variables POWERTOOLS_TRACER_CAPTURE_RESPONSE and POWERTOOLS_TRACER_CAPTURE_ERROR to false Disable on attribute 1 2 3 4 5 6 7 8 9 public class Function { [Tracing(CaptureMode = TracingCaptureMode.Disabled)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Disable Globally 1 2 3 4 5 6 7 8 9 10 11 12 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Runtime : dotnetcore3.1 Tracing : Active Environment : Variables : POWERTOOLS_TRACER_CAPTURE_RESPONSE : false POWERTOOLS_TRACER_CAPTURE_ERROR : false","title":"Lambda handler"},{"location":"core/tracing/#annotations-metadata","text":"Annotations are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions. Metadata are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional context for an operation using any native object. Annotations You can add annotations using AddAnnotation() method from Tracing 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Tracing ; public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . AddAnnotation ( \"annotation\" , \"value\" ); } } Metadata You can add metadata using AddMetadata() method from Tracing 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Tracing ; public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . AddMetadata ( \"content\" , \"value\" ); } }","title":"Annotations &amp; Metadata"},{"location":"core/tracing/#utilities","text":"Tracing modules comes with certain utility method when you don't want to use attribute for capturing a code block under a subsegment, or you are doing multithreaded programming. Refer examples below. Functional Api 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 using AWS.Lambda.Powertools.Tracing ; public class Function { public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . WithSubsegment ( \"loggingResponse\" , ( subsegment ) => { // Some business logic }); Tracing . WithSubsegment ( \"localNamespace\" , \"loggingResponse\" , ( subsegment ) => { // Some business logic }); } } Multi Threaded Programming 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using AWS.Lambda.Powertools.Tracing ; public class Function { public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { // Extract existing trace data var entity = Tracing . GetEntity (); var task = Task . Run (() => { Tracing . WithSubsegment ( \"InlineLog\" , entity , ( subsegment ) => { // Business logic in separate task }); }); } }","title":"Utilities"},{"location":"core/tracing/#instrumenting-sdk-clients-and-http-calls","text":"User should make sure to instrument the SDK clients explicitly based on the function dependency. Refer details on how to instrument SDK client with Xray and outgoing http calls .","title":"Instrumenting SDK clients and HTTP calls"}]}