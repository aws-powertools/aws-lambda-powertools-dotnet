{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AWS Lambda Powertools for .NET \u00b6 AWS Lambda Powertools for .NET (which from here will be referred as Powertools) is a suite of utilities for AWS Lambda functions to ease adopting best practices such as tracing, structured logging, custom metrics, and more. Please note, Powertools is optimized for .NET 6 only . The GitHub repository for this project can be found here . Do not use this library in production AWS Lambda Powertools for .NET is currently released in preview and is intended strictly for feedback purposes only. This version is not stable, and significant breaking changes might incur as part of the upcoming production-ready release. Your support is much appreciated. If you encounter any problems, please raise an issue . Do not use this library for production workloads. Available Powertools libraries \u00b6 Utility Description Tracing Decorators and utilities to trace Lambda function handlers, and both synchronous and asynchronous functions Logger Structured logging made easier, and decorator to enrich structured logging with key Lambda context details Metrics Custom AWS metrics created asynchronously via CloudWatch Embedded Metric Format (EMF) Install \u00b6 Powertools are available as NuGet packages. You can install the packages from NuGet gallery or from Visual Studio editor. Search AWS.Lambda.Powertools* to see various utilities available. AWS.Lambda.Powertools.Tracing : dotnet nuget add AWS.Lambda.Powertools.Tracing AWS.Lambda.Powertools.Logging : dotnet nuget add AWS.Lambda.Powertools.Logging AWS.Lambda.Powertools.Metrics : dotnet nuget add AWS.Lambda.Powertools.Metrics SAM CLI custom template \u00b6 We have provided you with a custom template for the Serverless Application Model (AWS SAM) command-line interface (CLI). This generates a starter project that allows you to interactively choose the Powertools features that enables you to include in your project. 1 sam init --location https://github.com/aws-samples/cookiecutter-aws-sam-dotnet To use the SAM CLI, you need the following tools. SAM CLI - Install the SAM CLI .NET 6.0 (LTS) - Install .NET 6.0 Docker - Install Docker community edition Examples \u00b6 We have provided a few examples that should you how to use the each of the core Powertools features. Tracing example Logging example Metrics example Other members of the AWS Lambda Powertools family \u00b6 Not using .NET? No problem we have you covered. Here are the other members of the AWS Lambda Powertools family: AWS Lambda Powertools for Python AWS Lambda Powertools for Java AWS Lambda Powertools for TypeScript Connect \u00b6 AWS Developers Slack : #lambda-powertools - Invite, if you don't have an account Email : aws-lambda-powertools-feedback@amazon.com Credits \u00b6 Credits for the Lambda Powertools idea go to DAZN and their DAZN Lambda Powertools .","title":"Homepage"},{"location":"#aws-lambda-powertools-for-net","text":"AWS Lambda Powertools for .NET (which from here will be referred as Powertools) is a suite of utilities for AWS Lambda functions to ease adopting best practices such as tracing, structured logging, custom metrics, and more. Please note, Powertools is optimized for .NET 6 only . The GitHub repository for this project can be found here . Do not use this library in production AWS Lambda Powertools for .NET is currently released in preview and is intended strictly for feedback purposes only. This version is not stable, and significant breaking changes might incur as part of the upcoming production-ready release. Your support is much appreciated. If you encounter any problems, please raise an issue . Do not use this library for production workloads.","title":"AWS Lambda Powertools for .NET"},{"location":"#available-powertools-libraries","text":"Utility Description Tracing Decorators and utilities to trace Lambda function handlers, and both synchronous and asynchronous functions Logger Structured logging made easier, and decorator to enrich structured logging with key Lambda context details Metrics Custom AWS metrics created asynchronously via CloudWatch Embedded Metric Format (EMF)","title":"Available Powertools libraries"},{"location":"#install","text":"Powertools are available as NuGet packages. You can install the packages from NuGet gallery or from Visual Studio editor. Search AWS.Lambda.Powertools* to see various utilities available. AWS.Lambda.Powertools.Tracing : dotnet nuget add AWS.Lambda.Powertools.Tracing AWS.Lambda.Powertools.Logging : dotnet nuget add AWS.Lambda.Powertools.Logging AWS.Lambda.Powertools.Metrics : dotnet nuget add AWS.Lambda.Powertools.Metrics","title":"Install"},{"location":"#sam-cli-custom-template","text":"We have provided you with a custom template for the Serverless Application Model (AWS SAM) command-line interface (CLI). This generates a starter project that allows you to interactively choose the Powertools features that enables you to include in your project. 1 sam init --location https://github.com/aws-samples/cookiecutter-aws-sam-dotnet To use the SAM CLI, you need the following tools. SAM CLI - Install the SAM CLI .NET 6.0 (LTS) - Install .NET 6.0 Docker - Install Docker community edition","title":"SAM CLI custom template"},{"location":"#examples","text":"We have provided a few examples that should you how to use the each of the core Powertools features. Tracing example Logging example Metrics example","title":"Examples"},{"location":"#other-members-of-the-aws-lambda-powertools-family","text":"Not using .NET? No problem we have you covered. Here are the other members of the AWS Lambda Powertools family: AWS Lambda Powertools for Python AWS Lambda Powertools for Java AWS Lambda Powertools for TypeScript","title":"Other members of the AWS Lambda Powertools family"},{"location":"#connect","text":"AWS Developers Slack : #lambda-powertools - Invite, if you don't have an account Email : aws-lambda-powertools-feedback@amazon.com","title":"Connect"},{"location":"#credits","text":"Credits for the Lambda Powertools idea go to DAZN and their DAZN Lambda Powertools .","title":"Credits"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. This project follows Keep a Changelog format for changes and adheres to Semantic Versioning . [Unreleased] \u00b6 [0.0.1-preview.1] - 2022-08-01 \u00b6 Added \u00b6 Public preview release","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. This project follows Keep a Changelog format for changes and adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"changelog/#001-preview1-2022-08-01","text":"","title":"[0.0.1-preview.1] - 2022-08-01"},{"location":"changelog/#added","text":"Public preview release","title":"Added"},{"location":"references/","text":"Environment variables \u00b6 Info Explicit parameters take precedence over environment variables. Environment variable Description Utility Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging All \"service_undefined\" POWERTOOLS_LOG_LEVEL Sets logging level Logging Information POWERTOOLS_LOGGER_CASE Override the default casing for log keys Logging SnakeCase POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event Logging false POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling Logging 0 POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics Metrics None POWERTOOLS_TRACE_DISABLED Disables tracing Tracing false POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. Tracing true POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. Tracing true SAM template snippets \u00b6 Logging \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. # SPDX-License-Identifier: MIT-0 AWSTemplateFormatVersion : \"2010-09-09\" Transform : AWS::Serverless-2016-10-31 Description : > Example project for Powertools Logging utility # More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst Globals : Function : Timeout : 10 Environment : Variables : POWERTOOLS_SERVICE_NAME : powertools-dotnet-logging-sample POWERTOOLS_LOG_LEVEL : Debug POWERTOOLS_LOGGER_LOG_EVENT : true POWERTOOLS_LOGGER_CASE : SnakeCase # Allowed values are: CamelCase, PascalCase and SnakeCase POWERTOOLS_LOGGER_SAMPLE_RATE : 0 Metrics \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. # SPDX-License-Identifier: MIT-0 AWSTemplateFormatVersion : \"2010-09-09\" Transform : AWS::Serverless-2016-10-31 Description : > Example project for Powertools Metrics utility # More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst Globals : Function : Timeout : 10 Environment : Variables : POWERTOOLS_SERVICE_NAME : powertools-dotnet-metrics-sample # This can also be set using the Metrics decorator on your handler [Metrics(Namespace = \"aws-lambda-powertools\"] POWERTOOLS_METRICS_NAMESPACE : AWSLambdaPowertools # This can also be set using the Metrics decorator on your handler [Metrics(Namespace = \"aws-lambda-powertools\"] Tracing \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. # SPDX-License-Identifier: MIT-0 AWSTemplateFormatVersion : \"2010-09-09\" Transform : AWS::Serverless-2016-10-31 Description : > Example project for Powertools tracing utility # More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst Globals : Function : Timeout : 10 Tracing : Active Environment : Variables : POWERTOOLS_SERVICE_NAME : powertools-dotnet-tracing-sample POWERTOOLS_TRACE_DISABLED : true POWERTOOLS_TRACER_CAPTURE_RESPONSE : true POWERTOOLS_TRACER_CAPTURE_ERROR : true # To disable tracing (CaptureMode = TracingCaptureMode.Disabled)","title":"References"},{"location":"references/#environment-variables","text":"Info Explicit parameters take precedence over environment variables. Environment variable Description Utility Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging All \"service_undefined\" POWERTOOLS_LOG_LEVEL Sets logging level Logging Information POWERTOOLS_LOGGER_CASE Override the default casing for log keys Logging SnakeCase POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event Logging false POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling Logging 0 POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics Metrics None POWERTOOLS_TRACE_DISABLED Disables tracing Tracing false POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. Tracing true POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. Tracing true","title":"Environment variables"},{"location":"references/#sam-template-snippets","text":"","title":"SAM template snippets"},{"location":"references/#logging","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. # SPDX-License-Identifier: MIT-0 AWSTemplateFormatVersion : \"2010-09-09\" Transform : AWS::Serverless-2016-10-31 Description : > Example project for Powertools Logging utility # More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst Globals : Function : Timeout : 10 Environment : Variables : POWERTOOLS_SERVICE_NAME : powertools-dotnet-logging-sample POWERTOOLS_LOG_LEVEL : Debug POWERTOOLS_LOGGER_LOG_EVENT : true POWERTOOLS_LOGGER_CASE : SnakeCase # Allowed values are: CamelCase, PascalCase and SnakeCase POWERTOOLS_LOGGER_SAMPLE_RATE : 0","title":"Logging"},{"location":"references/#metrics","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. # SPDX-License-Identifier: MIT-0 AWSTemplateFormatVersion : \"2010-09-09\" Transform : AWS::Serverless-2016-10-31 Description : > Example project for Powertools Metrics utility # More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst Globals : Function : Timeout : 10 Environment : Variables : POWERTOOLS_SERVICE_NAME : powertools-dotnet-metrics-sample # This can also be set using the Metrics decorator on your handler [Metrics(Namespace = \"aws-lambda-powertools\"] POWERTOOLS_METRICS_NAMESPACE : AWSLambdaPowertools # This can also be set using the Metrics decorator on your handler [Metrics(Namespace = \"aws-lambda-powertools\"]","title":"Metrics"},{"location":"references/#tracing","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. # SPDX-License-Identifier: MIT-0 AWSTemplateFormatVersion : \"2010-09-09\" Transform : AWS::Serverless-2016-10-31 Description : > Example project for Powertools tracing utility # More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst Globals : Function : Timeout : 10 Tracing : Active Environment : Variables : POWERTOOLS_SERVICE_NAME : powertools-dotnet-tracing-sample POWERTOOLS_TRACE_DISABLED : true POWERTOOLS_TRACER_CAPTURE_RESPONSE : true POWERTOOLS_TRACER_CAPTURE_ERROR : true # To disable tracing (CaptureMode = TracingCaptureMode.Disabled)","title":"Tracing"},{"location":"roadmap/","text":"Overview \u00b6 This is our public roadmap that outlines the high level direction we are working towards, namely Themes . We update this document when our priorities change: security and stability is our top priority. See our latest list of activities \u00bb Themes \u00b6 Themes are key activities maintainers are focusing on, besides bug reports. These are updated periodically and you can find the latest under Epics in our public board . Revamp roadmap \u00b6 We are beta testing the new GitHub Projects Beta to provide more visibility on our current activities. This also includes new GitHub Issue Forms Beta to streamline feature requests, bug reports, RFCs, etc., including a new mechanism to add external links like Ask a Question . Once complete, we will repurpose our central roadmap repository to provide a landing page for all Powertools languages, including an experiment to better highlight feature parity across them. Disclaimer \u00b6 The AWS Lambda Powertools team values feedback and guidance from its community of users, although final decisions on inclusion into the project will be made by AWS. We determine the high-level direction for our open roadmap based on customer feedback and popularity (\ud83d\udc4d\ud83c\udffd and comments), security and operational impacts, and business value. Where features don\u2019t meet our goals and longer-term strategy, we will communicate that clearly and openly as quickly as possible with an explanation of why the decision was made. FAQs \u00b6 Q: Why did you build this? A: We know that our customers are making decisions and plans based on what we are developing, and we want to provide our customers the insights they need to plan. Q: Why are there no dates on your roadmap? A: Because job zero is security and operational stability, we can't provide specific target dates for features. The roadmap is subject to change at any time, and roadmap issues in this repository do not guarantee a feature will be launched as proposed. Q: How can I provide feedback or ask for more information? A: For existing features, you can directly comment on issues. For anything else, please open an issue.","title":"Roadmap"},{"location":"roadmap/#overview","text":"This is our public roadmap that outlines the high level direction we are working towards, namely Themes . We update this document when our priorities change: security and stability is our top priority. See our latest list of activities \u00bb","title":"Overview"},{"location":"roadmap/#themes","text":"Themes are key activities maintainers are focusing on, besides bug reports. These are updated periodically and you can find the latest under Epics in our public board .","title":"Themes"},{"location":"roadmap/#revamp-roadmap","text":"We are beta testing the new GitHub Projects Beta to provide more visibility on our current activities. This also includes new GitHub Issue Forms Beta to streamline feature requests, bug reports, RFCs, etc., including a new mechanism to add external links like Ask a Question . Once complete, we will repurpose our central roadmap repository to provide a landing page for all Powertools languages, including an experiment to better highlight feature parity across them.","title":"Revamp roadmap"},{"location":"roadmap/#disclaimer","text":"The AWS Lambda Powertools team values feedback and guidance from its community of users, although final decisions on inclusion into the project will be made by AWS. We determine the high-level direction for our open roadmap based on customer feedback and popularity (\ud83d\udc4d\ud83c\udffd and comments), security and operational impacts, and business value. Where features don\u2019t meet our goals and longer-term strategy, we will communicate that clearly and openly as quickly as possible with an explanation of why the decision was made.","title":"Disclaimer"},{"location":"roadmap/#faqs","text":"Q: Why did you build this? A: We know that our customers are making decisions and plans based on what we are developing, and we want to provide our customers the insights they need to plan. Q: Why are there no dates on your roadmap? A: Because job zero is security and operational stability, we can't provide specific target dates for features. The roadmap is subject to change at any time, and roadmap issues in this repository do not guarantee a feature will be launched as proposed. Q: How can I provide feedback or ask for more information? A: For existing features, you can directly comment on issues. For anything else, please open an issue.","title":"FAQs"},{"location":"tenets/","text":"Core utilities such as Tracing, Logging, Metrics, and Event Handler will be available across all Powertools runtimes. Additional utilities are subjective to each language ecosystem and customer demand. AWS Lambda only . We optimize for AWS Lambda function environments and supported runtimes only. Utilities might work with web frameworks and non-Lambda environments, though they are not officially supported. Eases the adoption of best practices . The main priority of the utilities is to facilitate best practices adoption, as defined in the AWS Well-Architected Serverless Lens; all other functionality is optional. Keep it lean . Additional dependencies are carefully considered for security and ease of maintenance, and prevent negatively impacting startup time. We strive for backwards compatibility . New features and changes should keep backwards compatibility. If a breaking change cannot be avoided, the deprecation and migration process should be clearly defined. We work backwards from the community . We aim to strike a balance of what would work best for 80% of customers. Emerging practices are considered and discussed via Requests for Comment (RFCs) Idiomatic . Utilities follow programming language idioms and language-specific best practices.","title":"Our tenets"},{"location":"core/logging/","text":"The logging utility provides a Lambda optimized logger with output structured as JSON. Key features \u00b6 Capture key fields from Lambda context, cold start and structures logging output as JSON Log Lambda event when instructed (disabled by default) Log sampling enables DEBUG log level for a percentage of requests (disabled by default) Append additional keys to structured log at any point in time Getting started \u00b6 Logging requires two settings: Setting Description Environment variable Attribute parameter Service Sets Service key that will be present across all log statements POWERTOOLS_SERVICE_NAME Service Logging level Sets how verbose Logger should be (Information, by default) POWERTOOLS_LOG_LEVEL LogLevel Example using AWS Serverless Application Model (AWS SAM) \u00b6 You can override log level by setting POWERTOOLS_LOG_LEVEL environment variable in the AWS SAM template. You can also explicitly set a service name via POWERTOOLS_SERVICE_NAME environment variable. This sets Service key that will be present across all log statements. Here is an example using the AWS SAM Globals section . template.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. # SPDX-License-Identifier: MIT-0 AWSTemplateFormatVersion : \"2010-09-09\" Transform : AWS::Serverless-2016-10-31 Description : > Example project for Powertools Logging utility Globals : Function : Timeout : 10 Environment : Variables : POWERTOOLS_SERVICE_NAME : powertools-dotnet-logging-sample POWERTOOLS_LOG_LEVEL : Debug POWERTOOLS_LOGGER_LOG_EVENT : true POWERTOOLS_LOGGER_CASE : SnakeCase # Allowed values are: CamelCase, PascalCase and SnakeCase POWERTOOLS_LOGGER_SAMPLE_RATE : 0 Full list of environment variables \u00b6 Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging \"service_undefined\" POWERTOOLS_LOG_LEVEL Sets logging level Information POWERTOOLS_LOGGER_CASE Override the default casing for log keys SnakeCase POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event false POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling 0 Standard structured keys \u00b6 Your logs will always include the following keys to your structured logging: Key Type Example Description Timestamp string \"2020-05-24 18:17:33,774\" Timestamp of actual log statement Level string \"Information\" Logging level Name string \"Powertools Logger\" Logger name ColdStart bool true ColdStart value. Service string \"payment\" Service name defined. \"service_undefined\" will be used if unknown SamplingRate int 0.1 Debug logging sampling rate in percentage e.g. 10% in this case Message string \"Collecting payment\" Log statement value. Unserializable JSON values will be cast to string FunctionName string \"example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" FunctionVersion string \"12\" FunctionMemorySize string \"128\" FunctionArn string \"arn:aws:lambda:eu-west-1:012345678910:function:example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" XRayTraceId string \"1-5759e988-bd862e3fe1be46a994272793\" X-Ray Trace ID when Lambda function has enabled Tracing FunctionRequestId string \"899856cb-83d1-40d7-8611-9e78f15f32f4\" AWS Request ID from lambda context Logging incoming event \u00b6 When debugging in non-production environments, you can instruct Logger to log the incoming event with LogEvent parameter or via POWERTOOLS_LOGGER_LOG_EVENT environment variable. Warning Log event is disabled by default to prevent sensitive info being logged. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Setting a Correlation ID \u00b6 You can set a Correlation ID using CorrelationIdPath parameter by passing a JSON Pointer expression . Function.cs Example Event Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(CorrelationIdPath = \"/headers/my_request_id_header\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } 1 2 3 4 5 { \"headers\" : { \"my_request_id_header\" : \"correlation_id_value\" } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"cold_start\" : true , \"xray_trace_id\" : \"1-61b7add4-66532bb81441e1b060389429\" , \"function_name\" : \"test\" , \"function_version\" : \"$LATEST\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"level\" : \"Information\" , \"service\" : \"lambda-example\" , \"name\" : \"AWS.Lambda.Powertools.Logging.Logger\" , \"message\" : \"Collecting payment\" , \"sampling_rate\" : 0.7 , \"correlation_id\" : \"correlation_id_value\" , } We provide built-in JSON Pointer expression for known event sources, where either a request ID or X-Ray Trace ID are present. Function.cs Example Event Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(CorrelationIdPath = CorrelationIdPaths.API_GATEWAY_REST)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } 1 2 3 4 5 { \"RequestContext\" : { \"RequestId\" : \"correlation_id_value\" } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"cold_start\" : true , \"xray_trace_id\" : \"1-61b7add4-66532bb81441e1b060389429\" , \"function_name\" : \"test\" , \"function_version\" : \"$LATEST\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"level\" : \"Information\" , \"service\" : \"lambda-example\" , \"name\" : \"AWS.Lambda.Powertools.Logging.Logger\" , \"message\" : \"Collecting payment\" , \"sampling_rate\" : 0.7 , \"correlation_id\" : \"correlation_id_value\" , } Appending additional keys \u00b6 Custom keys are persisted across warm invocations Always set additional keys as part of your handler to ensure they have the latest value, or explicitly clear them with ClearState=true . You can append your own keys to your existing logs via AppendKey . Typically this value would be passed into the function via the event. Appended keys are added to all subsequent log entries in the current execution from the point the logger method is called. To ensure the key is added to all log entries, call this method as early as possible in the Lambda handler. Function.cs Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigwProxyEvent , ILambdaContext context ) { var requestContextRequestId = apigwProxyEvent . RequestContext . RequestId ; var lookupInfo = new Dictionary < string , object >() { { \"LookupInfo\" , new Dictionary < string , object >{{ \"LookupId\" , requestContextRequestId }}} }; // Appended keys are added to all subsequent log entries in the current execution. // Call this method as early as possible in the Lambda handler. // Typically this is value would be passed into the function via the event. // Set the ClearState = true to force the removal of keys across invocations, Logger . AppendKeys ( lookupInfo ); Logger . LogInformation ( \"Getting ip address from external service\" ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"cold_start\" : false , \"xray_trace_id\" : \"1-622eede0-647960c56a91f3b071a9fff1\" , \"lookup_info\" : { \"lookup_id\" : \"4c50eace-8b1e-43d3-92ba-0efacf5d1625\" }, \"function_name\" : \"PowertoolsLoggingSample-HelloWorldFunction-hm1r10VT3lCy\" , \"function_version\" : \"$LATEST\" , \"function_memory_size\" : 256 , \"function_arn\" : \"arn:aws:lambda:ap-southeast-2:538510314095:function:PowertoolsLoggingSample-HelloWorldFunction-hm1r10VT3lCy\" , \"function_request_id\" : \"96570b2c-f00e-471c-94ad-b25e95ba7347\" , \"timestamp\" : \"2022-03-14T07:25:20.9418065Z\" , \"level\" : \"Information\" , \"service\" : \"powertools-dotnet-logging-sample\" , \"name\" : \"AWS.Lambda.Powertools.Logging.Logger\" , \"message\" : \"Getting ip address from external service\" } Removing additional keys \u00b6 You can remove any additional key from entry using Logger.RemoveKeys() . Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... Logger . AppendKey ( \"test\" , \"willBeLogged\" ); ... var customKeys = new Dictionary < string , string > { { \"test1\" , \"value1\" }, { \"test2\" , \"value2\" } }; Logger . AppendKeys ( customKeys ); ... Logger . RemoveKeys ( \"test\" ); Logger . RemoveKeys ( \"test1\" , \"test2\" ); ... } } Extra Keys \u00b6 Extra keys allow you to append additional keys to a log entry. Unlike AppendKey , extra keys will only apply to the current log entry. Extra keys argument is available for all log levels' methods, as implemented in the standard logging library - e.g. Logger.Information, Logger.Warning. It accepts any dictionary, and all keyword arguments will be added as part of the root structure of the logs for that log statement. Info Any keyword argument added using extra keys will not be persisted for subsequent messages. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigwProxyEvent , ILambdaContext context ) { var requestContextRequestId = apigwProxyEvent . RequestContext . RequestId ; var lookupId = new Dictionary < string , object >() { { \"LookupId\" , requestContextRequestId } }; // Appended keys are added to all subsequent log entries in the current execution. // Call this method as early as possible in the Lambda handler. // Typically this is value would be passed into the function via the event. // Set the ClearState = true to force the removal of keys across invocations, Logger . AppendKeys ( lookupId ); } Clearing all state \u00b6 Logger is commonly initialized in the global scope. Due to Lambda Execution Context reuse , this means that custom keys can be persisted across invocations. If you want all custom keys to be deleted, you can use ClearState=true attribute on [Logging] attribute. Function.cs #1 Request #2 Request 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Handler for requests to Lambda function. */ public class Function { [Logging(ClearState = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... if ( apigProxyEvent . Headers . ContainsKey ( \"SomeSpecialHeader\" )) { Logger . AppendKey ( \"SpecialKey\" , \"value\" ); } Logger . LogInformation ( \"Collecting payment\" ); ... } } 1 2 3 4 5 6 7 8 9 10 11 12 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"special_key\" : \"value\" } 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" } Sampling debug logs \u00b6 You can dynamically set a percentage of your logs to DEBUG level via env var POWERTOOLS_LOGGER_SAMPLE_RATE or via SamplingRate parameter on attribute. Info Configuration on environment variable is given precedence over sampling rate configuration on attribute, provided it's in valid value range. Sampling via attribute parameter Sampling via environment variable 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(SamplingRate = 0.5)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } 1 2 3 4 5 6 7 8 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Environment : Variables : POWERTOOLS_LOGGER_SAMPLE_RATE : 0.5 Configure Log Output Casing \u00b6 By definition Powertools outputs logging keys using snake case (e.g. \"function_memory_size\": 128 ). This allows developers using different Powertools runtimes, to search logs across services written in languages such as Python or TypeScript. If you want to override the default behavior you can either set the desired casing through attributes, as described in the example below, or by setting the POWERTOOLS_LOGGER_CASE environment variable on your AWS Lambda function. Allowed values are: CamelCase , PascalCase and SnakeCase . Output casing via attribute parameter 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LoggerOutputCase = LoggerOutputCase.CamelCase)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Below are some output examples for different casing. Camel Case Pascal Case Snake Case 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"coldStart\" : true , \"functionName\" : \"test\" , \"functionMemorySize\" : 128 , \"functionArn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"functionRequestId\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" } 1 2 3 4 5 6 7 8 9 10 11 { \"Level\" : \"Information\" , \"Message\" : \"Collecting payment\" , \"Timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"Service\" : \"payment\" , \"ColdStart\" : true , \"FunctionName\" : \"test\" , \"FunctionMemorySize\" : 128 , \"FunctionArn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"FunctionRequestId\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" } 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" }","title":"Logging"},{"location":"core/logging/#key-features","text":"Capture key fields from Lambda context, cold start and structures logging output as JSON Log Lambda event when instructed (disabled by default) Log sampling enables DEBUG log level for a percentage of requests (disabled by default) Append additional keys to structured log at any point in time","title":"Key features"},{"location":"core/logging/#getting-started","text":"Logging requires two settings: Setting Description Environment variable Attribute parameter Service Sets Service key that will be present across all log statements POWERTOOLS_SERVICE_NAME Service Logging level Sets how verbose Logger should be (Information, by default) POWERTOOLS_LOG_LEVEL LogLevel","title":"Getting started"},{"location":"core/logging/#example-using-aws-serverless-application-model-aws-sam","text":"You can override log level by setting POWERTOOLS_LOG_LEVEL environment variable in the AWS SAM template. You can also explicitly set a service name via POWERTOOLS_SERVICE_NAME environment variable. This sets Service key that will be present across all log statements. Here is an example using the AWS SAM Globals section . template.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. # SPDX-License-Identifier: MIT-0 AWSTemplateFormatVersion : \"2010-09-09\" Transform : AWS::Serverless-2016-10-31 Description : > Example project for Powertools Logging utility Globals : Function : Timeout : 10 Environment : Variables : POWERTOOLS_SERVICE_NAME : powertools-dotnet-logging-sample POWERTOOLS_LOG_LEVEL : Debug POWERTOOLS_LOGGER_LOG_EVENT : true POWERTOOLS_LOGGER_CASE : SnakeCase # Allowed values are: CamelCase, PascalCase and SnakeCase POWERTOOLS_LOGGER_SAMPLE_RATE : 0","title":"Example using AWS Serverless Application Model (AWS SAM)"},{"location":"core/logging/#full-list-of-environment-variables","text":"Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging \"service_undefined\" POWERTOOLS_LOG_LEVEL Sets logging level Information POWERTOOLS_LOGGER_CASE Override the default casing for log keys SnakeCase POWERTOOLS_LOGGER_LOG_EVENT Logs incoming event false POWERTOOLS_LOGGER_SAMPLE_RATE Debug log sampling 0","title":"Full list of environment variables"},{"location":"core/logging/#standard-structured-keys","text":"Your logs will always include the following keys to your structured logging: Key Type Example Description Timestamp string \"2020-05-24 18:17:33,774\" Timestamp of actual log statement Level string \"Information\" Logging level Name string \"Powertools Logger\" Logger name ColdStart bool true ColdStart value. Service string \"payment\" Service name defined. \"service_undefined\" will be used if unknown SamplingRate int 0.1 Debug logging sampling rate in percentage e.g. 10% in this case Message string \"Collecting payment\" Log statement value. Unserializable JSON values will be cast to string FunctionName string \"example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" FunctionVersion string \"12\" FunctionMemorySize string \"128\" FunctionArn string \"arn:aws:lambda:eu-west-1:012345678910:function:example-powertools-HelloWorldFunction-1P1Z6B39FLU73\" XRayTraceId string \"1-5759e988-bd862e3fe1be46a994272793\" X-Ray Trace ID when Lambda function has enabled Tracing FunctionRequestId string \"899856cb-83d1-40d7-8611-9e78f15f32f4\" AWS Request ID from lambda context","title":"Standard structured keys"},{"location":"core/logging/#logging-incoming-event","text":"When debugging in non-production environments, you can instruct Logger to log the incoming event with LogEvent parameter or via POWERTOOLS_LOGGER_LOG_EVENT environment variable. Warning Log event is disabled by default to prevent sensitive info being logged. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } }","title":"Logging incoming event"},{"location":"core/logging/#setting-a-correlation-id","text":"You can set a Correlation ID using CorrelationIdPath parameter by passing a JSON Pointer expression . Function.cs Example Event Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(CorrelationIdPath = \"/headers/my_request_id_header\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } 1 2 3 4 5 { \"headers\" : { \"my_request_id_header\" : \"correlation_id_value\" } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"cold_start\" : true , \"xray_trace_id\" : \"1-61b7add4-66532bb81441e1b060389429\" , \"function_name\" : \"test\" , \"function_version\" : \"$LATEST\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"level\" : \"Information\" , \"service\" : \"lambda-example\" , \"name\" : \"AWS.Lambda.Powertools.Logging.Logger\" , \"message\" : \"Collecting payment\" , \"sampling_rate\" : 0.7 , \"correlation_id\" : \"correlation_id_value\" , } We provide built-in JSON Pointer expression for known event sources, where either a request ID or X-Ray Trace ID are present. Function.cs Example Event Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(CorrelationIdPath = CorrelationIdPaths.API_GATEWAY_REST)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } 1 2 3 4 5 { \"RequestContext\" : { \"RequestId\" : \"correlation_id_value\" } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"cold_start\" : true , \"xray_trace_id\" : \"1-61b7add4-66532bb81441e1b060389429\" , \"function_name\" : \"test\" , \"function_version\" : \"$LATEST\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"level\" : \"Information\" , \"service\" : \"lambda-example\" , \"name\" : \"AWS.Lambda.Powertools.Logging.Logger\" , \"message\" : \"Collecting payment\" , \"sampling_rate\" : 0.7 , \"correlation_id\" : \"correlation_id_value\" , }","title":"Setting a Correlation ID"},{"location":"core/logging/#appending-additional-keys","text":"Custom keys are persisted across warm invocations Always set additional keys as part of your handler to ensure they have the latest value, or explicitly clear them with ClearState=true . You can append your own keys to your existing logs via AppendKey . Typically this value would be passed into the function via the event. Appended keys are added to all subsequent log entries in the current execution from the point the logger method is called. To ensure the key is added to all log entries, call this method as early as possible in the Lambda handler. Function.cs Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigwProxyEvent , ILambdaContext context ) { var requestContextRequestId = apigwProxyEvent . RequestContext . RequestId ; var lookupInfo = new Dictionary < string , object >() { { \"LookupInfo\" , new Dictionary < string , object >{{ \"LookupId\" , requestContextRequestId }}} }; // Appended keys are added to all subsequent log entries in the current execution. // Call this method as early as possible in the Lambda handler. // Typically this is value would be passed into the function via the event. // Set the ClearState = true to force the removal of keys across invocations, Logger . AppendKeys ( lookupInfo ); Logger . LogInformation ( \"Getting ip address from external service\" ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"cold_start\" : false , \"xray_trace_id\" : \"1-622eede0-647960c56a91f3b071a9fff1\" , \"lookup_info\" : { \"lookup_id\" : \"4c50eace-8b1e-43d3-92ba-0efacf5d1625\" }, \"function_name\" : \"PowertoolsLoggingSample-HelloWorldFunction-hm1r10VT3lCy\" , \"function_version\" : \"$LATEST\" , \"function_memory_size\" : 256 , \"function_arn\" : \"arn:aws:lambda:ap-southeast-2:538510314095:function:PowertoolsLoggingSample-HelloWorldFunction-hm1r10VT3lCy\" , \"function_request_id\" : \"96570b2c-f00e-471c-94ad-b25e95ba7347\" , \"timestamp\" : \"2022-03-14T07:25:20.9418065Z\" , \"level\" : \"Information\" , \"service\" : \"powertools-dotnet-logging-sample\" , \"name\" : \"AWS.Lambda.Powertools.Logging.Logger\" , \"message\" : \"Getting ip address from external service\" }","title":"Appending additional keys"},{"location":"core/logging/#removing-additional-keys","text":"You can remove any additional key from entry using Logger.RemoveKeys() . Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... Logger . AppendKey ( \"test\" , \"willBeLogged\" ); ... var customKeys = new Dictionary < string , string > { { \"test1\" , \"value1\" }, { \"test2\" , \"value2\" } }; Logger . AppendKeys ( customKeys ); ... Logger . RemoveKeys ( \"test\" ); Logger . RemoveKeys ( \"test1\" , \"test2\" ); ... } }","title":"Removing additional keys"},{"location":"core/logging/#extra-keys","text":"Extra keys allow you to append additional keys to a log entry. Unlike AppendKey , extra keys will only apply to the current log entry. Extra keys argument is available for all log levels' methods, as implemented in the standard logging library - e.g. Logger.Information, Logger.Warning. It accepts any dictionary, and all keyword arguments will be added as part of the root structure of the logs for that log statement. Info Any keyword argument added using extra keys will not be persisted for subsequent messages. Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LogEvent = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigwProxyEvent , ILambdaContext context ) { var requestContextRequestId = apigwProxyEvent . RequestContext . RequestId ; var lookupId = new Dictionary < string , object >() { { \"LookupId\" , requestContextRequestId } }; // Appended keys are added to all subsequent log entries in the current execution. // Call this method as early as possible in the Lambda handler. // Typically this is value would be passed into the function via the event. // Set the ClearState = true to force the removal of keys across invocations, Logger . AppendKeys ( lookupId ); }","title":"Extra Keys"},{"location":"core/logging/#clearing-all-state","text":"Logger is commonly initialized in the global scope. Due to Lambda Execution Context reuse , this means that custom keys can be persisted across invocations. If you want all custom keys to be deleted, you can use ClearState=true attribute on [Logging] attribute. Function.cs #1 Request #2 Request 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Handler for requests to Lambda function. */ public class Function { [Logging(ClearState = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... if ( apigProxyEvent . Headers . ContainsKey ( \"SomeSpecialHeader\" )) { Logger . AppendKey ( \"SpecialKey\" , \"value\" ); } Logger . LogInformation ( \"Collecting payment\" ); ... } } 1 2 3 4 5 6 7 8 9 10 11 12 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" , \"special_key\" : \"value\" } 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" }","title":"Clearing all state"},{"location":"core/logging/#sampling-debug-logs","text":"You can dynamically set a percentage of your logs to DEBUG level via env var POWERTOOLS_LOGGER_SAMPLE_RATE or via SamplingRate parameter on attribute. Info Configuration on environment variable is given precedence over sampling rate configuration on attribute, provided it's in valid value range. Sampling via attribute parameter Sampling via environment variable 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(SamplingRate = 0.5)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } 1 2 3 4 5 6 7 8 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Environment : Variables : POWERTOOLS_LOGGER_SAMPLE_RATE : 0.5","title":"Sampling debug logs"},{"location":"core/logging/#configure-log-output-casing","text":"By definition Powertools outputs logging keys using snake case (e.g. \"function_memory_size\": 128 ). This allows developers using different Powertools runtimes, to search logs across services written in languages such as Python or TypeScript. If you want to override the default behavior you can either set the desired casing through attributes, as described in the example below, or by setting the POWERTOOLS_LOGGER_CASE environment variable on your AWS Lambda function. Allowed values are: CamelCase , PascalCase and SnakeCase . Output casing via attribute parameter 1 2 3 4 5 6 7 8 9 10 11 12 /** * Handler for requests to Lambda function. */ public class Function { [Logging(LoggerOutputCase = LoggerOutputCase.CamelCase)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Below are some output examples for different casing. Camel Case Pascal Case Snake Case 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"coldStart\" : true , \"functionName\" : \"test\" , \"functionMemorySize\" : 128 , \"functionArn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"functionRequestId\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" } 1 2 3 4 5 6 7 8 9 10 11 { \"Level\" : \"Information\" , \"Message\" : \"Collecting payment\" , \"Timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"Service\" : \"payment\" , \"ColdStart\" : true , \"FunctionName\" : \"test\" , \"FunctionMemorySize\" : 128 , \"FunctionArn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"FunctionRequestId\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" } 1 2 3 4 5 6 7 8 9 10 11 { \"level\" : \"Information\" , \"message\" : \"Collecting payment\" , \"timestamp\" : \"2021-12-13T20:32:22.5774262Z\" , \"service\" : \"payment\" , \"cold_start\" : true , \"function_name\" : \"test\" , \"function_memory_size\" : 128 , \"function_arn\" : \"arn:aws:lambda:eu-west-1:12345678910:function:test\" , \"function_request_id\" : \"52fdfc07-2182-154f-163f-5f0f9a621d72\" }","title":"Configure Log Output Casing"},{"location":"core/metrics/","text":"Metrics creates custom metrics asynchronously by logging metrics to standard output following Amazon CloudWatch Embedded Metric Format (EMF) . These metrics can be visualized through Amazon CloudWatch Console . Key features \u00b6 Aggregate up to 100 metrics using a single CloudWatch EMF object (large JSON blob) Validate against common metric definitions mistakes (metric unit, values, max dimensions, max metrics, etc) Metrics are created asynchronously by CloudWatch service, no custom stacks needed Context manager to create a one off metric with a different dimension Terminologies \u00b6 If you're new to Amazon CloudWatch, there are two terminologies you must be aware of before using this utility: Namespace . It's the highest level container that will group multiple metrics from multiple services for a given application, for example MyCompanyEcommerce . Dimensions . Metrics metadata in key-value format. They help you slice and dice metrics visualization, for example ColdStart metric by Payment service . Visit the AWS documentation for a complete explanation for Amazon CloudWatch concepts . Metric terminology, visually explained Getting started \u00b6 Metrics is implemented as a Singleton to keep track of your aggregate metrics in memory and make them accessible anywhere in your code. To guarantee that metrics are flushed properly the MetricsAttribute must be added on the lambda handler. Metrics has two global settings that will be used across all metrics emitted. Use your application or main service as the metric namespace to easily group all metrics: Setting Description Environment variable Constructor parameter Service Optionally, sets service metric dimension across all metrics e.g. payment POWERTOOLS_SERVICE_NAME Service Metric namespace Logical container where all metrics will be placed e.g. MyCompanyEcommerce POWERTOOLS_METRICS_NAMESPACE Namespace Autocomplete Metric Units All parameters in Metrics Attribute are optional. Following rules apply: Namespace: Empty string by default. You can either specify it in code or environment variable. If not present before flushing metrics, a SchemaValidationException will be thrown. Service: service_undefined by default. You can either specify it in code or environment variable. CaptureColdStart: false by default. RaiseOnEmptyMetrics: false by default. Example using AWS Serverless Application Model (AWS SAM) \u00b6 template.yml Function.cs 1 2 3 4 5 6 7 8 9 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Environment : Variables : POWERTOOLS_SERVICE_NAME : ShoppingCartService POWERTOOLS_METRICS_NAMESPACE : MyCompanyEcommerce 1 2 3 4 5 6 7 8 9 using AWS.Lambda.Powertools.Metrics ; public class Function { Metrics ( Namespace = \"MyCompanyEcommerce\" , Service = \"ShoppingCartService\" , CaptureColdStart = true , RaiseOnEmptyMetrics = true )] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } Full list of environment variables \u00b6 Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging \"service_undefined\" POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics None Creating metrics \u00b6 You can create metrics using AddMetric , and you can create dimensions for all your aggregate metrics using AddDimension method. Metrics Metrics with custom dimensions 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddDimension ( \"Environment\" , \"Prod\" ); Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } Autocomplete Metric Units MetricUnit enum facilitates finding a supported metric unit by CloudWatch. Metrics overflow CloudWatch EMF supports a max of 100 metrics per batch. Metrics utility will flush all metrics when adding the 100th metric. Subsequent metrics, e.g. 101th, will be aggregated into a new EMF object, for your convenience. Metric value must be a positive number Metric values must be a positive number otherwise an ArgumentException will be thrown. Do not create metrics or dimensions outside the handler Metrics or dimensions added in the global scope will only be added during cold start. Disregard if that's the intended behavior. Adding default dimensions \u00b6 You can use SetDefaultDimensions method to persist dimensions across Lambda invocations. SetDefaultDimensions method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using AWS.Lambda.Powertools.Metrics ; public class Function { private Dictionary < string , string > _defaultDimensions = new Dictionary < string , string >{ { \"Environment\" , \"Prod\" }, { \"Another\" , \"One\" } }; [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . SetDefaultDimensions ( _defaultDimensions ); Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } Flushing metrics \u00b6 With MetricsAttribute all your metrics are validated, serialized and flushed to standard output when lambda handler completes execution or when you had the 100th metric to memory. During metrics validation, if no metrics are provided then a warning will be logged, but no exception will be raised. Function.cs Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"BookingConfirmation\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"ExampleApplication\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"BookingConfirmation\" , \"Unit\" : \"Count\" } ] } ] }, \"service\" : \"ExampleService\" } Metric validation If metrics are provided, and any of the following criteria are not met, SchemaValidationException will be raised: Maximum of 9 dimensions Namespace is set Metric units must be supported by CloudWatch We do not emit 0 as a value for ColdStart metric for cost reasons. Let us know if you'd prefer a flag to override it Raising SchemaValidationException on empty metrics \u00b6 If you want to ensure that at least one metric is emitted, you can pass RaiseOnEmptyMetrics to the Metrics attribute: Function.cs 1 2 3 4 5 6 7 8 using AWS . Lambda . Powertools . Metrics ; public class Function { [ Metrics ( RaiseOnEmptyMetrics = true )] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... Capturing cold start metric \u00b6 You can optionally capture cold start metrics by setting CaptureColdStart parameter to true . Function.cs 1 2 3 4 5 6 7 8 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(CaptureColdStart = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... If it's a cold start invocation, this feature will: Create a separate EMF blob solely containing a metric named ColdStart Add function_name and service dimensions This has the advantage of keeping cold start metric separate from your application metrics, where you might have unrelated dimensions. Advanced \u00b6 Adding metadata \u00b6 You can add high-cardinality data as part of your Metrics log with AddMetadata method. This is useful when you want to search highly contextual information along with your metrics in your logs. Info This will not be available during metrics visualization - Use dimensions for this purpose Function.cs Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = ExampleApplication, Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); Metrics . AddMetadata ( \"BookingId\" , \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\" ); ... ```json hl_lines=\"23\" { \"SuccessfulBooking\": 1.0, \"_aws\": { \"Timestamp\": 1592234975665, \"CloudWatchMetrics\": [ { \"Namespace\": \"ExampleApplication\", \"Dimensions\": [ [ \"service\" ] ], \"Metrics\": [ { \"Name\": \"SuccessfulBooking\", \"Unit\": \"Count\" } ] } ] }, \"Service\": \"Booking\", \"BookingId\": \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\" } ``` Single metric with a different dimension \u00b6 CloudWatch EMF uses the same dimensions across all your metrics. Use PushSingleMetric if you have a metric that should have different dimensions. Info Generally, this would be an edge case since you pay for unique metric . Keep the following formula in mind: unique metric = (metric_name + dimension_name + dimension_value) Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = ExampleApplication, Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . PushSingleMetric ( metricName : \"ColdStart\" , value : 1 , unit : MetricUnit . COUNT , nameSpace : \"ExampleApplication\" , service : \"Booking\" , defaultDimensions : new Dictionary < string , string > { { \"FunctionContext\" , \"$LATEST\" } }); ...","title":"Metrics"},{"location":"core/metrics/#key-features","text":"Aggregate up to 100 metrics using a single CloudWatch EMF object (large JSON blob) Validate against common metric definitions mistakes (metric unit, values, max dimensions, max metrics, etc) Metrics are created asynchronously by CloudWatch service, no custom stacks needed Context manager to create a one off metric with a different dimension","title":"Key features"},{"location":"core/metrics/#terminologies","text":"If you're new to Amazon CloudWatch, there are two terminologies you must be aware of before using this utility: Namespace . It's the highest level container that will group multiple metrics from multiple services for a given application, for example MyCompanyEcommerce . Dimensions . Metrics metadata in key-value format. They help you slice and dice metrics visualization, for example ColdStart metric by Payment service . Visit the AWS documentation for a complete explanation for Amazon CloudWatch concepts . Metric terminology, visually explained","title":"Terminologies"},{"location":"core/metrics/#getting-started","text":"Metrics is implemented as a Singleton to keep track of your aggregate metrics in memory and make them accessible anywhere in your code. To guarantee that metrics are flushed properly the MetricsAttribute must be added on the lambda handler. Metrics has two global settings that will be used across all metrics emitted. Use your application or main service as the metric namespace to easily group all metrics: Setting Description Environment variable Constructor parameter Service Optionally, sets service metric dimension across all metrics e.g. payment POWERTOOLS_SERVICE_NAME Service Metric namespace Logical container where all metrics will be placed e.g. MyCompanyEcommerce POWERTOOLS_METRICS_NAMESPACE Namespace Autocomplete Metric Units All parameters in Metrics Attribute are optional. Following rules apply: Namespace: Empty string by default. You can either specify it in code or environment variable. If not present before flushing metrics, a SchemaValidationException will be thrown. Service: service_undefined by default. You can either specify it in code or environment variable. CaptureColdStart: false by default. RaiseOnEmptyMetrics: false by default.","title":"Getting started"},{"location":"core/metrics/#example-using-aws-serverless-application-model-aws-sam","text":"template.yml Function.cs 1 2 3 4 5 6 7 8 9 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Environment : Variables : POWERTOOLS_SERVICE_NAME : ShoppingCartService POWERTOOLS_METRICS_NAMESPACE : MyCompanyEcommerce 1 2 3 4 5 6 7 8 9 using AWS.Lambda.Powertools.Metrics ; public class Function { Metrics ( Namespace = \"MyCompanyEcommerce\" , Service = \"ShoppingCartService\" , CaptureColdStart = true , RaiseOnEmptyMetrics = true )] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } }","title":"Example using AWS Serverless Application Model (AWS SAM)"},{"location":"core/metrics/#full-list-of-environment-variables","text":"Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging \"service_undefined\" POWERTOOLS_METRICS_NAMESPACE Sets namespace used for metrics None","title":"Full list of environment variables"},{"location":"core/metrics/#creating-metrics","text":"You can create metrics using AddMetric , and you can create dimensions for all your aggregate metrics using AddDimension method. Metrics Metrics with custom dimensions 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddDimension ( \"Environment\" , \"Prod\" ); Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } Autocomplete Metric Units MetricUnit enum facilitates finding a supported metric unit by CloudWatch. Metrics overflow CloudWatch EMF supports a max of 100 metrics per batch. Metrics utility will flush all metrics when adding the 100th metric. Subsequent metrics, e.g. 101th, will be aggregated into a new EMF object, for your convenience. Metric value must be a positive number Metric values must be a positive number otherwise an ArgumentException will be thrown. Do not create metrics or dimensions outside the handler Metrics or dimensions added in the global scope will only be added during cold start. Disregard if that's the intended behavior.","title":"Creating metrics"},{"location":"core/metrics/#adding-default-dimensions","text":"You can use SetDefaultDimensions method to persist dimensions across Lambda invocations. SetDefaultDimensions method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 using AWS.Lambda.Powertools.Metrics ; public class Function { private Dictionary < string , string > _defaultDimensions = new Dictionary < string , string >{ { \"Environment\" , \"Prod\" }, { \"Another\" , \"One\" } }; [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . SetDefaultDimensions ( _defaultDimensions ); Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } }","title":"Adding default dimensions"},{"location":"core/metrics/#flushing-metrics","text":"With MetricsAttribute all your metrics are validated, serialized and flushed to standard output when lambda handler completes execution or when you had the 100th metric to memory. During metrics validation, if no metrics are provided then a warning will be logged, but no exception will be raised. Function.cs Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = \"ExampleApplication\", Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"BookingConfirmation\" : 1.0 , \"_aws\" : { \"Timestamp\" : 1592234975665 , \"CloudWatchMetrics\" : [ { \"Namespace\" : \"ExampleApplication\" , \"Dimensions\" : [ [ \"service\" ] ], \"Metrics\" : [ { \"Name\" : \"BookingConfirmation\" , \"Unit\" : \"Count\" } ] } ] }, \"service\" : \"ExampleService\" } Metric validation If metrics are provided, and any of the following criteria are not met, SchemaValidationException will be raised: Maximum of 9 dimensions Namespace is set Metric units must be supported by CloudWatch We do not emit 0 as a value for ColdStart metric for cost reasons. Let us know if you'd prefer a flag to override it","title":"Flushing metrics"},{"location":"core/metrics/#raising-schemavalidationexception-on-empty-metrics","text":"If you want to ensure that at least one metric is emitted, you can pass RaiseOnEmptyMetrics to the Metrics attribute: Function.cs 1 2 3 4 5 6 7 8 using AWS . Lambda . Powertools . Metrics ; public class Function { [ Metrics ( RaiseOnEmptyMetrics = true )] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ...","title":"Raising SchemaValidationException on empty metrics"},{"location":"core/metrics/#capturing-cold-start-metric","text":"You can optionally capture cold start metrics by setting CaptureColdStart parameter to true . Function.cs 1 2 3 4 5 6 7 8 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(CaptureColdStart = true)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... If it's a cold start invocation, this feature will: Create a separate EMF blob solely containing a metric named ColdStart Add function_name and service dimensions This has the advantage of keeping cold start metric separate from your application metrics, where you might have unrelated dimensions.","title":"Capturing cold start metric"},{"location":"core/metrics/#advanced","text":"","title":"Advanced"},{"location":"core/metrics/#adding-metadata","text":"You can add high-cardinality data as part of your Metrics log with AddMetadata method. This is useful when you want to search highly contextual information along with your metrics in your logs. Info This will not be available during metrics visualization - Use dimensions for this purpose Function.cs Example CloudWatch Logs excerpt 1 2 3 4 5 6 7 8 9 10 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = ExampleApplication, Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . AddMetric ( \"SuccessfulBooking\" , 1 , MetricUnit . COUNT ); Metrics . AddMetadata ( \"BookingId\" , \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\" ); ... ```json hl_lines=\"23\" { \"SuccessfulBooking\": 1.0, \"_aws\": { \"Timestamp\": 1592234975665, \"CloudWatchMetrics\": [ { \"Namespace\": \"ExampleApplication\", \"Dimensions\": [ [ \"service\" ] ], \"Metrics\": [ { \"Name\": \"SuccessfulBooking\", \"Unit\": \"Count\" } ] } ] }, \"Service\": \"Booking\", \"BookingId\": \"683EEB2D-B2F3-4075-96EE-788E6E2EED45\" } ```","title":"Adding metadata"},{"location":"core/metrics/#single-metric-with-a-different-dimension","text":"CloudWatch EMF uses the same dimensions across all your metrics. Use PushSingleMetric if you have a metric that should have different dimensions. Info Generally, this would be an edge case since you pay for unique metric . Keep the following formula in mind: unique metric = (metric_name + dimension_name + dimension_value) Function.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using AWS.Lambda.Powertools.Metrics ; public class Function { [Metrics(Namespace = ExampleApplication, Service = \"Booking\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Metrics . PushSingleMetric ( metricName : \"ColdStart\" , value : 1 , unit : MetricUnit . COUNT , nameSpace : \"ExampleApplication\" , service : \"Booking\" , defaultDimensions : new Dictionary < string , string > { { \"FunctionContext\" , \"$LATEST\" } }); ...","title":"Single metric with a different dimension"},{"location":"core/tracing/","text":"Powertools tracing is an opinionated thin wrapper for AWS X-Ray .NET SDK a provides functionality to reduce the overhead of performing common tracing tasks. Key Features \u00b6 Helper methods to improve the developer experience for creating custom AWS X-Ray subsegments . Capture cold start as annotation. Capture function responses and full exceptions as metadata. Better experience when developing with multiple threads. Auto-patch supported modules by AWS X-Ray Getting Started \u00b6 Before you use this utility, your AWS Lambda function must have permissions to send traces to AWS X-Ray. To enable active tracing on an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function resource, use the Tracing property. You can use the Globals section of the AWS SAM template to set this for all Using AWS Serverless Application Model (AWS SAM) \u00b6 template.yaml 1 2 3 4 5 6 7 8 9 10 11 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Runtime : dotnet6.0 Tracing : Active Environment : Variables : POWERTOOLS_SERVICE_NAME : example The Powertools service name is used as the X-Ray namespace. This can be set using the environment variable POWERTOOLS_SERVICE_NAME Full list of environment variables \u00b6 Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging \"service_undefined\" POWERTOOLS_TRACE_DISABLED Disables tracing false POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. true POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. true Lambda handler \u00b6 To enable Powertools tracing to your function add the [Tracing] attribute to your FunctionHandler method or on any method will capture the method as a separate subsegment automatically. You can optionally choose to customize segment name that appears in traces. Tracing attribute Custom Segment names 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { await BusinessLogic1 () . ConfigureAwait ( false ); await BusinessLogic2 () . ConfigureAwait ( false ); } [Tracing] private async Task BusinessLogic1 () { } [Tracing] private async Task BusinessLogic2 () { } } 1 2 3 4 5 6 7 8 9 public class Function { [Tracing(SegmentName = \"YourCustomName\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } By default, this attribute will automatically record method responses and exceptions. You can change the default behavior by setting the environment variables POWERTOOLS_TRACER_CAPTURE_RESPONSE and POWERTOOLS_TRACER_CAPTURE_ERROR as needed. Optionally, you can override behavior by different supported CaptureMode to record response, exception or both. Returning sensitive information from your Lambda handler or functions, where Tracing is used? You can disable attribute from capturing their responses and exception as tracing metadata with captureMode=DISABLED or globally by setting environment variables POWERTOOLS_TRACER_CAPTURE_RESPONSE and POWERTOOLS_TRACER_CAPTURE_ERROR to false Disable on attribute Disable Globally 1 2 3 4 5 6 7 8 9 public class Function { [Tracing(CaptureMode = TracingCaptureMode.Disabled)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } 1 2 3 4 5 6 7 8 9 10 11 12 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Runtime : dotnetcore3.1 Tracing : Active Environment : Variables : POWERTOOLS_TRACER_CAPTURE_RESPONSE : false POWERTOOLS_TRACER_CAPTURE_ERROR : false Annotations & Metadata \u00b6 Annotations are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions. Metadata are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional context for an operation using any native object. Annotations Metadata You can add annotations using AddAnnotation() method from Tracing 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Tracing ; public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . AddAnnotation ( \"annotation\" , \"value\" ); } } You can add metadata using AddMetadata() method from Tracing 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Tracing ; public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . AddMetadata ( \"content\" , \"value\" ); } } Utilities \u00b6 Tracing modules comes with certain utility method when you don't want to use attribute for capturing a code block under a subsegment, or you are doing multithreaded programming. Refer examples below. Functional Api Multi Threaded Programming 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 using AWS.Lambda.Powertools.Tracing ; public class Function { public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . WithSubsegment ( \"loggingResponse\" , ( subsegment ) => { // Some business logic }); Tracing . WithSubsegment ( \"localNamespace\" , \"loggingResponse\" , ( subsegment ) => { // Some business logic }); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using AWS.Lambda.Powertools.Tracing ; public class Function { public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { // Extract existing trace data var entity = Tracing . GetEntity (); var task = Task . Run (() => { Tracing . WithSubsegment ( \"InlineLog\" , entity , ( subsegment ) => { // Business logic in separate task }); }); } } Instrumenting SDK clients and HTTP calls \u00b6 User should make sure to instrument the SDK clients explicitly based on the function dependency. Refer details on how to instrument SDK client with Xray and outgoing http calls .","title":"Tracing"},{"location":"core/tracing/#key-features","text":"Helper methods to improve the developer experience for creating custom AWS X-Ray subsegments . Capture cold start as annotation. Capture function responses and full exceptions as metadata. Better experience when developing with multiple threads. Auto-patch supported modules by AWS X-Ray","title":"Key Features"},{"location":"core/tracing/#getting-started","text":"Before you use this utility, your AWS Lambda function must have permissions to send traces to AWS X-Ray. To enable active tracing on an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function resource, use the Tracing property. You can use the Globals section of the AWS SAM template to set this for all","title":"Getting Started"},{"location":"core/tracing/#using-aws-serverless-application-model-aws-sam","text":"template.yaml 1 2 3 4 5 6 7 8 9 10 11 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Runtime : dotnet6.0 Tracing : Active Environment : Variables : POWERTOOLS_SERVICE_NAME : example The Powertools service name is used as the X-Ray namespace. This can be set using the environment variable POWERTOOLS_SERVICE_NAME","title":"Using AWS Serverless Application Model (AWS SAM)"},{"location":"core/tracing/#full-list-of-environment-variables","text":"Environment variable Description Default POWERTOOLS_SERVICE_NAME Sets service name used for tracing namespace, metrics dimension and structured logging \"service_undefined\" POWERTOOLS_TRACE_DISABLED Disables tracing false POWERTOOLS_TRACER_CAPTURE_RESPONSE Captures Lambda or method return as metadata. true POWERTOOLS_TRACER_CAPTURE_ERROR Captures Lambda or method exception as metadata. true","title":"Full list of environment variables"},{"location":"core/tracing/#lambda-handler","text":"To enable Powertools tracing to your function add the [Tracing] attribute to your FunctionHandler method or on any method will capture the method as a separate subsegment automatically. You can optionally choose to customize segment name that appears in traces. Tracing attribute Custom Segment names 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { await BusinessLogic1 () . ConfigureAwait ( false ); await BusinessLogic2 () . ConfigureAwait ( false ); } [Tracing] private async Task BusinessLogic1 () { } [Tracing] private async Task BusinessLogic2 () { } } 1 2 3 4 5 6 7 8 9 public class Function { [Tracing(SegmentName = \"YourCustomName\")] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } By default, this attribute will automatically record method responses and exceptions. You can change the default behavior by setting the environment variables POWERTOOLS_TRACER_CAPTURE_RESPONSE and POWERTOOLS_TRACER_CAPTURE_ERROR as needed. Optionally, you can override behavior by different supported CaptureMode to record response, exception or both. Returning sensitive information from your Lambda handler or functions, where Tracing is used? You can disable attribute from capturing their responses and exception as tracing metadata with captureMode=DISABLED or globally by setting environment variables POWERTOOLS_TRACER_CAPTURE_RESPONSE and POWERTOOLS_TRACER_CAPTURE_ERROR to false Disable on attribute Disable Globally 1 2 3 4 5 6 7 8 9 public class Function { [Tracing(CaptureMode = TracingCaptureMode.Disabled)] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { ... } } 1 2 3 4 5 6 7 8 9 10 11 12 Resources : HelloWorldFunction : Type : AWS::Serverless::Function Properties : ... Runtime : dotnetcore3.1 Tracing : Active Environment : Variables : POWERTOOLS_TRACER_CAPTURE_RESPONSE : false POWERTOOLS_TRACER_CAPTURE_ERROR : false","title":"Lambda handler"},{"location":"core/tracing/#annotations-metadata","text":"Annotations are key-values associated with traces and indexed by AWS X-Ray. You can use them to filter traces and to create Trace Groups to slice and dice your transactions. Metadata are key-values also associated with traces but not indexed by AWS X-Ray. You can use them to add additional context for an operation using any native object. Annotations Metadata You can add annotations using AddAnnotation() method from Tracing 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Tracing ; public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . AddAnnotation ( \"annotation\" , \"value\" ); } } You can add metadata using AddMetadata() method from Tracing 1 2 3 4 5 6 7 8 9 10 11 using AWS.Lambda.Powertools.Tracing ; public class Function { [Tracing] public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . AddMetadata ( \"content\" , \"value\" ); } }","title":"Annotations &amp; Metadata"},{"location":"core/tracing/#utilities","text":"Tracing modules comes with certain utility method when you don't want to use attribute for capturing a code block under a subsegment, or you are doing multithreaded programming. Refer examples below. Functional Api Multi Threaded Programming 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 using AWS.Lambda.Powertools.Tracing ; public class Function { public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { Tracing . WithSubsegment ( \"loggingResponse\" , ( subsegment ) => { // Some business logic }); Tracing . WithSubsegment ( \"localNamespace\" , \"loggingResponse\" , ( subsegment ) => { // Some business logic }); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 using AWS.Lambda.Powertools.Tracing ; public class Function { public async Task < APIGatewayProxyResponse > FunctionHandler ( APIGatewayProxyRequest apigProxyEvent , ILambdaContext context ) { // Extract existing trace data var entity = Tracing . GetEntity (); var task = Task . Run (() => { Tracing . WithSubsegment ( \"InlineLog\" , entity , ( subsegment ) => { // Business logic in separate task }); }); } }","title":"Utilities"},{"location":"core/tracing/#instrumenting-sdk-clients-and-http-calls","text":"User should make sure to instrument the SDK clients explicitly based on the function dependency. Refer details on how to instrument SDK client with Xray and outgoing http calls .","title":"Instrumenting SDK clients and HTTP calls"}]}